
VLDB 2017
43rd International Conference on Very Large Data Bases
     Reviews For Paper
Track	     Research -> September 2016
Paper ID     460
Title Portal: A Query Language for Evolving Graphs
Masked Reviewer ID:   Assigned_Reviewer_1
Review:		
Question	 
Overall Rating	 Reject
Summary of the paper (what is being proposed and in what context) and a brief justification of your overall recommendation. One paragraph This paper addresses the problem of querying and analyzing evolving (temporal) graphs. The problem looks important and it seems more work need to be done in this area. The main contributions of the paper are: i) TGraph - a data model and algebra for temporal graphs, and ii) Portal - a system that implements TGraph. The data model is simple and incremental with respect to the state of the art. The proposed algebra is very interesting and provides a rich foundation for querying temporal graphs. However, the algebra is not formally proven to be correct. It is hard to see the novelty of Portal as the technical aspects of this system are not discussed.
Three (or more) strong points about the paper (Please be precise and explicit; clearly explain the value and nature of the contribution). S1- The problem of querying and analyzing evolving graphs is of practical importance.
S2- The proposed algebra provides a rich foundation for querying temporal graphs.
S3- Performance study with both synthetic and real datasets
Three (or more) weak points about the paper (Please indicate clearly whether the paper has any mistakes, missing related work, or results that cannot be considered a contribution; write it so that the authors can understand what are seen as negative aspect W1- The writing needs improvements
W2- Related work needs improvements
W2- Experimental evaluation needs improvement.
Relevant for PVLDB	    YES
Novelty (Please give a high novelty ranking to papers on new topics, opening new fields, or proposing truly new ideas; assign medium ratings for delta papers and papers on well known topics but still with some valuable contribution). With some new ideas
Significance	Improvement over existing work
Technical Depth and Quality of Content	  Syntactically complete but with limited contribution
Experiments	OK, but certain claims are not covered by the experiments
Presentation	Sub-standard: would require heavy rewrite
Detailed Evaluation (Contribution, Pros/Cons, Errors); please number each point	D1 The novelty of the paper and contributions

The title of the paper refers to Portal as a query language. Then, the paper refers to Portal as a system that implements TGraph (which could be the query language!). The novelty of the system aspects, such as temporal locality, physical data representation, and data partitioning, is hard to be seen. The paper would be much stronger if the authors emphasized these aspect and discussed what is new here. The other option is to focus more on the language aspects and provide proof of correctness. 

D2 the Introduction

Overall, I find the Introduction to be very brief and not very informative of the paper. The style of starting off paragraph with questions is somehow confusing. I believe authors should reconsider and rewrite the introduction in a more classic way that makes it easy to read and follow. 

"Efficient graph abstractions and analytics for static graphs are to researchers and practitioners in scope of open source platforms such as Apache Giraph, Apache Spark (through GraphX [14] and GraphLab (through the PowerGraph library [13])." This sentence is not clear. It doesn't read well. Need to be rephrased. 

There is a lot of use of italic font in the Introduction. This seems to defeat the purpose of highlighting important keywords/issues. 

Introduction Section starts mentioning about Portal (which is based on TGraph) before talking about TGraph). This is confusing. I suggest authors to reorganize Introduction Section so it has a better flow of reading.

D3 Data Model and Algebra 

The authors mentioned that "The basic building block of our model is a TGraph". Based on Definition 2.2. TGraph "T^RG is a valid-time period-based relation that associates a state of the graph g with a time period p during which the graph is in that state." 
Then as seen in Section 4 and 5, RG, which "is a direct implementation of TRG of Definition 2.2.", does not perform well in most of the cases. Moreover, Section 5 confirmed that "In summary, no one data structure is most efficient across all operations." 

This is confusing. The authors did not say that the objective is to just investigate different data structures and study their performance without providing an efficient solution. In this case the paper would presented as a study for different alternative without recommending a certain solution for providing an efficient system for the proposed algebra. 

The authors presented an alternative to their adopted model (T^RG). This alternative is in "Definition 2.3 decouples evolution of graph vertices, edges and attribute values, coalescing each relation independently of the others."
Then authors mentioned that "This makes graph maintenance and manipulation more manageable.". The model would be strong if the authors clearly confirmed that non of the proposed data models is efficient and provided a clear analysis to their trade-off. For example why a certain data model "makes graph maintenance and manipulation more manageable." and what is the cost of other alternative. 


In Page 3, "SQL:2011 does not provide a way to specify that a relation be coalesced, and does not enable efficient mechanisms to implement the coalesce operator." 
There is work done in providing an efficient coalescing mechanism for relational data, please see [CME]. This might be of interest for the authors to improve the performance of the VE data model in supporting analytics. 

In Section 3, page 4. The authors said "Instead, we compute a consistent result by removing the tuples that violate referential integrity." 
This is confusing. What do you mean by removing? do we support remove "delete" from the history! Do you mean intermediate data or the actual temporal graph. 

In Page 5, "Note that, because TGraph algebra is compositional, we do not support temporal aggregation with overlapping windows, because it does not produce a valid TGraph."
It is not clear why. 

D4 The system

Section 4 lacks the formalism of many components. Besides, there is no detailed technical description about how things work. The section would be stronger if the authors provided an algorithm for the lazy coalescing, discussed its complexity. Moreover, it is interesting to give more details to justify the novelty of the proposed temporal locality and data partitioning. 
For example, it is needed to discuss the differences between the proposed temporal locality and the one proposed by [Chronos]. Same thing also should be done for the proposed parallel processing and partitioning.

Figure 5 is hard to understand. 

Page 9 "in Section 5, the current HG implementation already improves performance compared to OG, in some cases significantly." Section 5 shows only one case where HG outperforms OG. Unfortunately, the authors did not discuss here the cost of building/constructing data structures, such as HG and OG. 

D5 The evaluation 

The evaluation would be way better if the authors compared against the stat of the art systems, such as [Chronos] and [kineograph]. As the authors mentioned in the related work section "Their model is also a sequence of snapshots with the integer time domain. The version graph can be extended to support the period-based model, and is similar to our OG repesentation.". It is interesting to compare the OG,HG and RG against the stat of the art systems, such as [Chronos] and [kineograph], in supporting analytics. 

The evaluation section has to provide a clear analysis of the cost of constructing these data structures OG,HG and RG. Yes, these structures provide better performance for analytic operations but with hidden cost, the construction cost. The authors can enrich the paper also by discussing their mechanism in manipulating these data structures after update operations. Is it manipulated incrementally or they need to rebuild them from scratch. 


D6 Related work

The related work section would be enriched if the authors considered also the above references plus the following 
-   Kumar Sricharan and Kamalika Das. 2014. Localizing anomalous changes in time-evolving graphs. In Proceedings of the 2014 ACM SIGMOD International Conference on Management of Data (SIGMOD '14).

- Bo Zong, Xusheng Xiao, Zhichun Li, Zhenyu Wu, Zhiyun Qian, Xifeng Yan, Ambuj K. Singh, and Guofei Jiang. 2015. Behavior query discovery in system-generated temporal graphs. Proc. VLDB Endow. 9, 4 (December 2015), 240-251. 

---------- REF----------


[CME] Mohammed Al-Kateb, Essam Mansour, Mohamed E. El-Sharkawi:
CME: A Temporal Relational Model for Efficient Coalescing. TIME 2005: 83-90

[Chronos] Wentao Han, Youshan Miao, Kaiwei Li, Ming Wu, Fan Yang, Lidong Zhou, Vijayan Prabhakaran, Wenguang Chen, and Enhong Chen. 2014. Chronos: a graph engine for temporal graph analysis. In Proceedings of the Ninth European Conference on Computer Systems (EuroSys '14).

[kineograph] Raymond Cheng, Ji Hong, Aapo Kyrola, Youshan Miao, Xuetian Weng, Ming Wu, Fan Yang, Lidong Zhou, Feng Zhao, and Enhong Chen. 2012. Kineograph: taking the pulse of a fast-changing and connected world. In Proceedings of the 7th ACM european conference on Computer Systems (EuroSys '12).
Masked Reviewer ID:  Assigned_Reviewer_2
Review:		
Question	 
Overall Rating	 Weak Reject
Summary of the paper (what is being proposed and in what context) and a brief justification of your overall recommendation. One paragraph This is potentially interesting research in temporal graph query languages. The authors point out that temporal graphs are emerging as a hot topic. They present two models for representing a temporal graph, and some query language operators for processing the models. They implement the operators in a big data system and experiment evaluating the operators on four temporal graph representations. The main problem with this paper is that it lacks a section on expressiveness of the query language. The authors need to show that this set of operators is both necessary and sufficient for all (or at least many) temporal graph queries. Instead the authors describe a (seemingly random) collection of operators, do not show how the operators address the motivating queries nor describe the expressiveness or power of the operators. Also absent is an experimental and expressiveness comparison with other temporal graph query languages. It may be that Portal is a superior temporal graph query language, but more work is needed to demonstrate it.
Three (or more) strong points about the paper (Please be precise and explicit; clearly explain the value and nature of the contribution). 1) Hot topic
2) Experimental evaluation
3) Temporal aggregation considered
Three (or more) weak points about the paper (Please indicate clearly whether the paper has any mistakes, missing related work, or results that cannot be considered a contribution; write it so that the authors can understand what are seen as negative aspect 1) Expressiveness of language is unclear
2) No experimental/expressivness comparison with other temporal graph query languages
3) Modeling coiuld be improved
Relevant for PVLDB YES
Novelty (Please give a high novelty ranking to papers on new topics, opening new fields, or proposing truly new ideas; assign medium ratings for delta papers and papers on well known topics but still with some valuable contribution). Novel
Significance	Improvement over existing work
Technical Depth and Quality of Content	  Syntactically complete but with limited contribution
Experiments	OK, but certain claims are not covered by the experiments
Presentation	Reasonable: improvements needed
Detailed Evaluation (Contribution, Pros/Cons, Errors); please number each point	Section 1
“…over evolving graphs still lacks.”
over evolving graphs is still lacking.

Perhaps give an explanation of why the name Portal was chosen, as it is not evocative of temporality.

The representative graphs structure is space-inefficient since the graph is repeated for every membership-constant period. The vertex-edge representation on the other hand seems inefficient at run-time since joins are needed to follow a path in the graph. Why not combine the two into a representation where edges and nodes are timestamped? This would combine the best features of the representative and vertex-edge graphs.

These are interesting kinds of queries, one hopes that the authors will return to these queries to show how they are expressed in the query language later in the paper.

Contribution 1 claims novelty of representation as the contribution. Novelty of a poor representation however would not be a contribution, so a better claim would be an space or time efficient representation. Also, for novelty of representation as a contribution the representation has to be clever, it has to be something other than straightforward. It is unclear that either the representative graph or the vertex-edge graph are anything other than slight adaptations of timestamped edges and vertexes. It is not clear what is new here.

Contribution 2 could be strengthened by showing that the algebra is complete and sound. Soundness should be easy to show, however, the algebra is incomplete. A few operators have been implemented, but it is seems a weak contribution.

Contribution 4 is not a contribution, rather it is an evaluation of Contributions 1-3.

Section 2
Period intersection is given, but not union or difference?

In Definition 2.2, for 2) it would be better to use p \intersect p’ since you introduced period intersection before (no two time periods of tuples intersect). And for 1) it is cleaner to use “not (p meets p’ or p’ meets p)” since 2) states that none intersects already (switch 2) and 1)), overlaps and contains are not needed, and the extra p’ meets p is actually needed.

The authors perhaps make a mistake by stating a “bag of properties” is associated with each vertex/edge. They mean a “set of properties” since the properties cannot be a bag with coalesced representation (value-equivalent duplicates are merged across time). For instance in Figure 2 assuming name=Bob is duplicated in a bag of properties, then are there two tuples with name=Bob or one tuple with name=Bob twice or both and how is it that the lifetime of each duplicate is known say if one duplicate lives from 1-4 and the other from 3-6 then is name=Bob from 1-6 one of the tuples? Generally, coalesced representation implies sets. Also, definition 2.2. is built on sets of nodes/edges, so in several ways, “bag of properties” seems incorrect as A^E would then have to be a bag.

The last sentence of Section 2.1 is out of place since it says that coalesced representation is space-efficient, but since the entire graph is duplicated for every time period for which there is any difference in the graph, the representative model is hopelessly space inefficient, coalesced or not, it makes no practical difference.

As the vertex-edge model uses valid-time SQL relations, duplicate tuples are permitted, though not in a coalesced relation. Refer to 
@inproceedings{Dignos:2012:TA:2213836.2213886,
author = {Dign\"{o}s, Anton and B\"{o}hlen, Michael H. and Gamper, Johann},
title = {Temporal Alignment},
booktitle = {Proceedings of the 2012 ACM SIGMOD International Conference on Management of Data},
series = {SIGMOD '12},
year = {2012},
isbn = {978-1-4503-1247-9},
location = {Scottsdale, Arizona, USA},
pages = {433--444},
numpages = {12},
url = {http://doi.acm.org/10.1145/2213836.2213886},
doi = {10.1145/2213836.2213886},
acmid = {2213886},
publisher = {ACM},
address = {New York, NY, USA},
keywords = {sequenced semantics, temporal databases},
} 
for using lineage to track duplicates in valid-time SQL.

Same comments for cleaning up definition 2.2 apply to 2.3. But 2.3 has other problems. In a graph model, two separate edges may connect a pair of vertices with different properties at the same time. This is quite common in some RDF graphs (multiple relationships between objects). The edges would be “OR” semantics on how to move between the vertices, using one or the other edge. But in the VE model, the edge would be coalesced to a single edge, and the properties associated with each would then be mixed. In the mixing the original graph cannot be recovered since it is not known which property belongs to which edge (there are no edge identifiers). The authors need to be more descriptive about what kinds of graphs are supported, and/or add edge identifiers.

When coalescing with respect to SQL:2011 is discussed it is important for the authors to motivate why coalescing is important to their model, when non-coalesced is fine for SQL:2011. There are strong correctness arguments for preserving duplicates (see Dignos et al.). The authors need to motivate why they consider coalescing to be important.

Interestingly, when discussing the columnar representation, note that it will not be coalesced. name=bob for instance will occur with different, contiguous time periods in the column as it appears in multiple name/value sets.

Section 2.3 needs to be revised if more than one edge connecting a pair of vertices is considered.

At the start of Section 3 the authors must present the expressiveness of Portal. Why choose only some operators? Why limit temporal aggregation? Why do map but not reduce? The main problem with the algebra is why a non-complete set of operators was chosen. Temporal difference is somewhat important. Temporal outer join would also be useful. At least a page is needed describing the expressiveness of Portal vs. TSQL2 vs. Dignos et. al. vs. other temporal graph query languages. Kleene closure is also missing (see Boehlen’s work or temporal datalog).

It would be interesting for the authors to consider the complete temporal algebra given by by Dignos et al. The expense of the coalescing operator can probably be avoided for unary operators. Also, as the properties of these operators are described already in [4] is it necessary to reiterate which is coalesce-preserving etc? This does not seem like a contribution. 

At the end of Section 3, come back to the queries presented as motivation and show how each is expressed in Portal. It seems quite impossible to this reader for some of the motivating queries to be given in Portal (especially with the restricted temporal aggregation). The authors miss a huge opportunity here. 

It is probably best to discus lazy coalescing as a query optimization technique and present a suite of other temporal query optimization techniques, or make clear that all of the non-temporal query optimization still holds when temporal operators are used (this is not clear at all at present, but critical to good performance). Lazy coalescing and other potential temporal query optimization techniques can be claimed as a contribution if novel (lazy coalescing seems like something already done, but could be new).

In Section 4, it is a strawman to compare with T^RG, which is a very inefficient representation. Do others use this representation at all? Why weren’t OG and HG introduced as potential models in Section 2? They seem the obvious timestamping of a graph model, timestamp edges and vertices, this seems obvious, so why not present these models in Section 2?

When discussing partitioning in Section 4, there are papers on temporal partitioning, e.g., 
@inproceedings{DBLP:conf/sigmod/LeLTC13,
author = {Wangchao Le and
Feifei Li and
Yufei Tao and
Robert Christensen},
title = {Optimal splitters for temporal and multi-version databases},
booktitle = {Proceedings of the {ACM} {SIGMOD} International Conference on Management
of Data, {SIGMOD} 2013, New York, NY, USA, June 22-27, 2013},
pages = {109--120},
year = {2013},
crossref = {DBLP:conf/sigmod/2013},
url = {http://doi.acm.org/10.1145/2463676.2465310},
doi = {10.1145/2463676.2465310},
timestamp = {Mon, 23 May 2016 12:16:24 +0200},
biburl = {http://dblp.uni-trier.de/rec/bib/conf/sigmod/LeLTC13},
bibsource = {dblp computer science bibliography, http://dblp.org}
}
It would be best to discuss temporal partitioning as well.

The experiments are interesting, but the authors should also experiment with the motivating queries introduced in the introduction, and compare against the other temporal graph query implementations, which they cite. The comparison with others would show advancement in the state-of-the-art.

It would be best to also implement using Pregel or another graph DB/processing system.



Masked Reviewer ID: Assigned_Reviewer_3
Review:		
Question	 
Overall Rating	 Reject
Summary of the paper (what is being proposed and in what context) and a brief justification of your overall recommendation. One paragraph The paper proposes an algenra for evolving graphs. The solution is implemented as a system that is based on Apache Spark.
Three (or more) strong points about the paper (Please be precise and explicit; clearly explain the value and nature of the contribution). s1) System implementation
s2) Relevant problem
Three (or more) weak points about the paper (Please indicate clearly whether the paper has any mistakes, missing related work, or results that cannot be considered a contribution; write it so that the authors can understand what are seen as negative aspect w1) Organization as research paper is preliminary and is not at the level of a VLDB paper
w2) Analytical parts are missing
w3) Presentation needs substantial work
Relevant for PVLDB     YES
Novelty (Please give a high novelty ranking to papers on new topics, opening new fields, or proposing truly new ideas; assign medium ratings for delta papers and papers on well known topics but still with some valuable contribution). Novelty unclear
Significance	No impact
Technical Depth and Quality of Content	Syntactically complete but with limited contribution
Experiments	OK, but certain claims are not covered by the experiments
Presentation	Sub-standard: would require heavy rewrite
Detailed Evaluation (Contribution, Pros/Cons, Errors); please number each point	The authors propose an algebraic query language for evolving graphs. This is an interesting and relevant topic.

The implementation with GraphX and Apache Spark, and the free availability of the code is good.

The paper is still at a too preliminary stage and not ready for publication in VLDB.

The bulk of the paper in section 3 proposes a list of algebraic operators for evolving graphs. It is useful to describe, define and illustrate the operations of the algebra. However some reflection and analysis is needed as well. At the end the reader must understand why the proposed algebra is good, what its properties are, etc. It is good to work this out as easily identifiable and precise scientific results (lemmas, theorems).

The discussion of, respectively, vertex-edge TGraph and TGraph should be reconsidered. What is the benefit of introducing and using both notations? Clearly both models can be used to model an evolving graph. Maybe the vertex-edge TGraph should only be used in an implementation section. Having to deal with two equivalent models/representations unnecessarily complicates things.

An important concept that the authors mention throughout is coalescing. It is not completely clear whether this shall be an operation or is part of the model (i.e., only coalesced information is permitted). You write that "Coalescing requires that the system automatically merge adjacent and overlapping time periods". It seems coalescing in this sentence refers to a model property and not an operation. This should be clarified in the text.

I found the handling of the database integrity very puzzling. The authors write that they do not reject a change that would lead to a violation of the referential integrity. They do this to to get a useful algebra. Instead they compute a consistent result by removing the tuples that violate referntial integrity. Why is a rejection of changes that violate integrity not useful? That is what all database systems do.

In the experimental evaluation it would be important to empirically compare with other solutions and systems.

The related work lacks a detailed discussion of other query languages/algenras for graph databases.


 
