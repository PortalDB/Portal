\section{Model}
\label{sec:model}

The basic element of our model is a \tg, which represents a graph that
evolves continuously over time.  A \tg represents evolution of graph
topology, i.e., the presence or absence of its vertices and edges, and
of the values of vertex and edge attributes.  Our choice to represent
continuous graph evolution is in contrast to a less-general discrete
snapshot-based representation.  We will discuss this distrinction
further in Section~\ref{sec:related}.

Following the SQL:2011
standard~\cite{DBLP:journals/sigmod/KulkarniM12}, we adopt the {\em
  closed-open} period model, where a time period (or time interval)
represents a continuous set of time instances, starting from and
including the start time, continuing to but excluding the end time.

\begin{definition}[Time period]
A {\em time period} \\$p = [start, end)$ is an interval of the
  continuous time domain $T$, subject to the constraint $start < end$.
\label{def:period} 
\end{definition}

\begin{figure}
\centering
\includegraphics[width=2.5in]{figs/T1_relations.pdf}
\caption{\tg \insql{T1} as a sequence of changes to vertices and edges.}
\label{fig:tg_ve}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=3in]{figs/T1_tables.pdf}
\caption{\tg \insql{T1} as a pair of temporal SQL relations.}
\label{fig:tg_tab}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=3in]{figs/T1_graphs.pdf}
\caption{\tg \insql{T1} as a sequence of representative graphs.}
\label{fig:tg_rg}
\end{figure}

\eat{
It will be useful to quantify relationships between time periods $p$
and $q$ using the following Allen's relations~\cite{allen83}. }

\eat{\begin{itemize}
\item $p equal q$, defined as $p.start = q.start \wedge p.end = q.end$
\item $p overlaps q$, defined as $p.end > q.start$
\item $p meets q$, defined as $p.end = q.start$
\item $p during q$, defines as $p.start > q.start \wedge p.end < q.end$ 
\item $p starts q$, defined as $p.start = q.start \wedge p.end < q.end$
\item $p finishes q$, defined as $p.start > q.start \wedge p.end = q.end$
\end{itemize}}

We now define a \tg, the basic building block of our model that
represents an evolving graph with a pair of temporal SQL relations $V$
and $E$.  

\begin{definition}[TGraph]
An {\em evolving graph} \tg is a pair $(V; E)$, where $V$ is a finite
set of nodes with schema $V(\underline{v}, \underline{p}, a_1,
\ldots, a_n)$, and $E$ is a finite set of edges connecting pairs of
nodes from $V$, with schema $E(\underline{v_1}, \underline{v_2},
\underline{p}, b_1, \ldots, b_m)$, subject to the following
conditions:
\begin{align*}
\forall E(v_1, v_2, p)~~\exists V(v_1, p_1), V(v_2, p_2)~~|~~\\
                       \pred{p_1}{contains}{p}~\wedge~\pred{p_2}{contains}{p}\\
\forall V(v, p, a_1, \ldots, a_n)~~\nexists V(v, p', a_1, \ldots, a_n)~~|~~ \\
                       \pred{p}{meets}{p'}~\lor~\pred{p}{contains}{p'}~\lor~\pred{p}{overlaps}{p'}\\
\forall E(v_1, v_2, p,  b_1, \ldots, b_m)~~\nexists E(v_1,v_2, p', b_1, \ldots, b_m)~~|~~\\
                       \pred{p}{meets}{p'}~\lor~\pred{p}{contains}{p'}~\lor~\pred{p}{overlaps}{p'}
\end{align*}

\label{def:tg}
\end{definition}

The graph represented by \tg may be directed or undirected.  For
undirected graphs we choose a canonical representation of an edge, with
$v_1 \leq v_2$ (self-loops are allowed).

The first condition in Definition~\ref{def:tg} states the natural
integrity constraint that an edge linking two vertices can only exist
during a time when both vertices exist.  Here, $\pred{p}{contains}{q}$
is the Allen \predName{contains} relation with
equality~\cite{allen83}, defined as $p.start \leq q.start \wedge p.end
\geq q.end$.  Consider the vertex-edge representation of \tg
\insql{T1} in Figure~\ref{fig:tg_ve}, where edge $e(v_1,v_2)$ exists
during the entire period when both $v_1$ and $v_2$ exist, while edge
$e(v_2,v_3)$ exists only for a portion of the period when both $v_2$
and $v_3$ exist.

The second and third conditions in Definition~\ref{def:tg} state that
\tg is coalesced~\cite{DBLP:conf/vldb/BohlenSS96}, which means that
each entity (vertex or edge) is represented exactly once for each time
period of maximal length when it is present, and when none of the
values of its attributes change.  Semantically, this means that the
entity exists continously through the entire time period.  Here,
again, \predName{meets}, \predName{contains} and \predName{overlaps}
are the corresponding Allen relations~\cite{allen83}, with
equality. Consider the contents of $V$ and $E$ relations of \insql{T1}
in Figure~\ref{fig:tg_tables}, and note that there is a single tuple
corresponding to vertex $v_1$ in $V$, but two tuples corresponding to
$v_2$, because the value of the attribute $school$ of $v_2$ changed at
time $t_3$.

The \tg of Definition~\ref{def:tg} (with only the key attributes) is
implemented in temporal SQL as follows:

\begin{small}
\begin{verbatim}
CREATE TABLE V (
  v LONG,
  pstart DATE,
  pend DATE,
  PERIOD for p (pstart, pend),
  PRIMARY KEY (v, p WITHOUT OVERLAPS) )

CREATE TABLE E (
  v1 LONG,
  v2 LONG,
  pstart DATE,
  pend DATE,
  PERIOD for p (pstart, pend),
  PRIMARY KEY (v1, v2, p WITHOUT OVERLAPS),
  FOREIGN KEY (v1, PERIOD p) REFERENCES V(v, PERIOD p),
  FOREIGN KEY (v2, PERIOD p) REFERENCES V(v, PERIOD p) )
\end{verbatim}
\end{small}

Coalescing requires that the system automatically merge adjacent and
overlapping time periods.  This operation, which is similar to
duplicate elimination in conventional databases, has been studied in
the
literature~\cite{DBLP:conf/vldb/BohlenSS96,DBLP:journals/sigmod/Zimanyi06},
but is not fully supported by the SQL:2011 standard.  The
implementation above enforces that time periods do not overlap, but it
does not prevent the existence of two adjacent time periods for the
same $v$ in $V$, and for the same $(v_1, v_2)$ in $E$, i.e., periods
$p$ and $q$ for which $\pred{p}{meets}{q}$ holds are not merged.
Perhaps more importantly, there is no convenient and efficient
implementation of the coalesce operator in temporal SQL.
See~\cite{DBLP:reference/db/Bohlen09} for SQL implementations of the
coalesce operator.

Note that, while it is an important property of our logical model that
time periods be coalesced, eagerly coalescing is both expensive and,
in some cases, unnecessary.  We will discuss this in detail when
presenting \tg algebra (Section~\ref{sec:algebra}) and its
implementation (Section~\ref{sec:system}).

Non-key attributes of $V$ and $E$ are not restricted to be of atomic
types, but may, e.g., be maps or tuples.  Because of this, \ql
supports {\em schema evolution} in a \tg in much the same way as is
done in popular (non-temporal) graph databases like Neo4j~\cite{}.  At
an extreme, the vertex (resp. edge) relation will have a single
unstructured non-key attribute, which would store all attribute
information.  This representation has the usual advantages and
disadvantages --- flexibility of a schema-less representation at the
expense of missed performance optimization opportunities afforded by a
structured representation.

To conclude, let us revisit \tg \insql{T1} in Figure~\ref{fig:ve}
Figure~\ref{fig:rg} represents \insql{T1} as a continuous sequence of
states, each corresponding to time periods $p_1 \ldots p_5$ in which
no change occured to the graph (to either its topology or to the
attribute values of its vertices and edges).  This view, to which we
refer as {\em representative graphs} of a \tg, is an important
abstraction when discussing the operations of \tg algebra, presented
in the next section.
