\subsection{Coalescing}
\label{sec:sys:coal}

\julia{I have a lock on this section.}

\eat{
\begin{table}
\small
\begin{tabular}{ l | p{4cm} | c }
\hline
\multicolumn{1}{l|}{\bfseries Operation} & \multicolumn{1}{c|}{\bfseries Requires Coalesced Input} & \multicolumn{1}{c}{\bfseries Uncoalesces} \\ \hline
slice & no & no \\ \hline
select & only if predicate incl. interval & no \\ \hline
project & no & yes \\ \hline
aggregate & only if structural group by is used and includes interval & yes \\ \hline
union & no & yes \\ \hline
intersection & no & yes \\ \hline
analytics & no & yes \\
\hline
\end{tabular}
\caption{Coalesce analysis.}
\label{tab:coalesce}
\end{table}
}

All operations and all sequences of operations must output a valid
temporally coalesced \tg.  The \ql system supports both eager and lazy
coalescing, with lazy being the default behavior for multi-operator
queries.  Interestingly, correctness of most \tg algebra operations
does not depend on whether the input was coalesced, and so coalescing
can be deferred.  The following are unconditional coalescing rules,
assuming $T, \tve, \trg$ are uncoalesced.

The first rule eliminates successive coalescing:

\begin{equation}
coal(coal(T)) \equiv coal(T)
\label{rul:coalr0}
\end{equation}

Rules in ~\cref{rul:coalr1,rul:coalr2,rul:coalr3} exploit the
fact that some operations preserve coalescing, as shown in
Section~\ref{sec:algebra}:

\begin{equation}
coal(\tau_c(coal(T))) \equiv \tau_c(coal(T))
\label{rul:coalr1}
\end{equation}
\begin{equation}
coal(\sigma_f(coal(\tve))) \equiv \sigma_f(coal(\tve))
\label{rul:coalr2}
\end{equation}
\begin{equation}
coal(udf(coal(T))) \equiv udf(coal(T))
\label{rul:coalr3}
\end{equation}

Rules in
~\cref{rul:coalr4,rul:coalr5,rul:coalr6,rul:coalr7,rul:coalr8,rul:coalr9}
cover operations which are invariant with respect to time and so
coalescing can be postponed until after the operation:

\begin{equation}
\tau_c(coal(T)) \equiv coal(\tau_c(T))
\label{rul:coalr4}
\end{equation}

Recall that slice selects each entity with an interval that intersects
with $c$ and modifies only the selected tuple periods to $p \cap c$.
According to the rule~\ref{rul:coalr1}, slice does not uncoalesce.  If
the input relation is uncoalesced, it contains some value-equivalent
tuples with adjacent or overlapping periods.  According to the
definitions of $intersect$ and $coalesce$, an intersect with interval
$p$ is the same as the coalesce of intersects of intervals composing
$p$.  I.e., $p \cap c = (p1 \cap c) \cup (p2 \cap c$) where $p = p1
\cup p2$.  Thus coalescing can be performed before or after slice.

\begin{equation}
coal(\sigma_f(coal(T))) \equiv coal(\sigma_f(T))
\label{rul:coalr5}
\end{equation}

As shown in~\cite{DBLP:conf/vldb/BohlenSS96}, coalescing can be
deferred until after the selection if the selection condition is
independent of the valid time of the input. Since subgraph is a
time-invariant form of select, coalesce is not required prior to
subgraph.  For both this rule and the slice rule above, deferring
coalescing can be quite effective if the selectivity of the predicate
is high.

\begin{equation}
coal(\mu(coal(T))) \equiv coal(\mu(T))
\label{rul:coalr6}
\end{equation}

The map operation processes each tuple without modifying the
corresponding intervals and independently of the valid time of the
input.  Thus, as above, coalesce can be deferred.

\begin{equation}
coal(coal(T_1) \cap coal(T_2)) \equiv coal(T_1 \cap T_2)
\label{rul:coalr7}
\end{equation}

\begin{equation}
coal(coal(T_1) \cup coal(T_2)) \equiv coal(T_1 \cup T_2)
\label{rul:coalr8}
\end{equation}

For \trg, temporal graph intersection is a inner theta-join followed
by projection.  As shown in~\cite{DBLP:conf/vldb/BohlenSS96},
coalescing can be deferred until after a join and after a projection
if that projection is independent of the valid time interval of the
tuple, which is the case here.  Thus we can defer coalescing until
after the temporal graph intersection.  Temporal graph union is also a
join, albeit an outer one, so the same argument applies.

\begin{equation}
coal(udf(coal(T))) \equiv coal(udf(T))
\label{rul:coalr9}
\end{equation}

If the \tg is not coalesced, it contains one or more value-equivalent
representative graphs with consecutive or overlapping periods.
Analytics are time-invariant functions applied to each representative
graph.  Thus when applied to value-equivalent graphs, they will
produce equivalent results.  Because analytics tend to be
computationally expensive operations, it may be beneficial to eagerly
coalesce before them so that they are executed on a smaller number of
graphs.

When aggregating by change, the input must be coalesced to compute
correct aggregation windows.  If the input is not coalesced, then
there may be two or more consecutive intervals which should be treated
as one but would count separately. For aggregate by time, some
aggregate functions also require coalesced input.  For example, count
aggregate will produce different result if several consecutive or
overlapping value-equivalent tuples fall within the same window.  Thus
we add the following conditional coalescing rules:

\begin{multline}
coal(\gamma_{W,Q_V,Q_E,f_V,f_E}(coal(T))) \equiv coal(\gamma_{W,Q_V,Q_E,f_V,f_E}(T)) \\
iff~~f_V \in \{any | first | last | min | max\}~~\wedge \\
f_E \in \{any | first | last | min | max\}
\label{rul:coalr10}
\end{multline}

$any$ aggregate returns one of the entity values in the aggregation
window, with no guarantees as to which one.  It is clear that it is
invariant to time or the number of grouped tuples.  $first$ and $last$
aggregates pick temporally earliest, resp. latest, value in each
group.  If $T$ is uncoalesced, they is at least one pair of
value-equivalent tuples with overlapping or consecutive periods.
Selecting between equivalent values will generate the same result
regardless of the number of those values.  The same argument applies
to $min$ and $max$.

Finally, a rule that eliminates coalescing of coalesced \tgs:

\begin{equation}
coal(T) \equiv T~~iff~~is\_coalesced(T)
\label{rul:coalr11}
\end{equation}

This last rule is very useful if the data on disk is known to be
coalesced.

There are several different implementations possible for the coalesce
operation over temporal SQL relations,
see~\cite{DBLP:conf/vldb/BohlenSS96} for detailed analysis.  We use a
partitioning method, where the relation (e.g., \tv, \te, \trg) is
grouped by key, and within each group the tuples are sorted and folded
to produce the corresponding time periods of maximum length.  This
approach involves shuffling between partitions, one of the most
computationally expensive aspects of distributed systems, and thus
lazy coalescing is preferred in most cases.\eat{ As with duplicate
  elimination, if the coalesced output is expected to be significantly
  reduced in size, such as after a project operation on a high
  volatility attribute, performing coalesce eagerly before a
  time-consuming operation, especially analytics, can be
  advantageous.}
