\subsection{Reducing operators}
\label{sec:props:reduce}

Spark is not a temporal system.  Following the approach of Dignos et
al.~\cite{Dignos2012} we reduce our temporal operators into a sequence
of nontemporal relational operators, maintaining point semantics.  We
need several operators on individual temporal relations in \tve which
we term {\em primitives}: extend, trim, coalesce, normalize, and
constrain, in order to support the operators of \ql algebra.

\eat{Since our model is using point
semantics, we do not support the property of change preservation.  }

The {\em extend} primitive $\epsilon(\mathbf{r})$ extends a relation
with an additional attribute which for each tuple is equivalent to
that tuple's timestamp.  See~\cite{Dignos2012} for the formal
definition.  The extend primitive allows references to the timestamps
in the temporal predicates and join conditions making time information
into data.

The {\em trim} primitive $\mathcal{I}(\mathbf{r},c)$ modifies the
timestamp of each tuple in a relation $\mathbf{r}$ to the result of
its intersection with input period $c$.  Assuming $A$ is a set of
non-temporal attributes of relation {\bf r}, $z \in
\mathcal{I}(\mathbf{r},c) \iff \exists r \in \mathbf{r}(z.A = r.A
\wedge z.p = r.p \cap c)$.

The {\em coalesce} primitive $\mathcal{C}(\mathbf{r})$ merges adjacent
and overlapping time periods.  This operation, which is similar to
duplicate elimination in conventional databases, has been extensively
studied in the
literature~\cite{DBLP:conf/vldb/BohlenSS96,DBLP:journals/sigmod/Zimanyi06}.
Eager coalescing is not desirable since it is expensive and some
operations may produce correct results (up to coalescing) {\em even
  when computing over uncoalesced inputs}.  \eat{This was discussed in
  the context of temporal relational algebra
  in~\cite{DBLP:conf/vldb/BohlenSS96}.}We will revisit this point in
Section~\ref{sec:sys:coal}.

The {\em normalize} primitive, indicated by $\mathcal{N}_B(r;s)$
produces a set of tuples for each tuple in {\bf r} by splitting its
timestamp into non-overlapping periods with respect to another
relation {\bf s} and attributes {\bf B}.  See~\cite{Dignos2012} for
the formal definition.

The {\em constrain} primitive $\mathcal{K}_k(r;s)$ constrains relation
$\mathbf{r}$ with respect to relation $\mathbf{s}$ by key $k$, such as
removing edges from the result that do not have associated nodes, or
trimming the edge validity period to be within the validity periods of
associated nodes.  It is introduced here because Spark does not have a
built-in way to express foreign key constraints.

The implementation of each of these primitives is discussed in
Section~\ref{sec:sys:maint}.

Our reduction rules assume that the four constituent parts of \tve are
extended and are as follows:

\begin{table*}
\small
\begin{tabular}{ | p{1.4cm} p{2.5cm} c L{12.1cm} | }
\hline
\multicolumn{1}{|l}{\bfseries Operator} & & & \multicolumn{1}{c|}{\bfseries Reduction} \\ \hline
\multicolumn{4}{|l|}{trim = $\mathcal{I}$; coalesce = $\mathcal{C}$; normalize = $\mathcal{N}$; constrain = $\mathcal{K}$} \\ \hline
Slice & $\tau_c (\ttt)$ & $=$ & $\forall x \in \{\tv,\te,\tav,\tae \}, x' = \mathcal{I}( \sigma_{p \cap c} (x), c)$ \\
Subgraph & $\sigma_{C_V,C_E} (\ttt)$ & $=$ & $\tv' = \mathcal{C}(\pi_{v,p} (\sigma_{C_{V1}}(\mathcal{N}_v(\tv, \tav)) \bowtie_{v,p} \sigma_{C_{V2}}(\mathcal{N}_v(\tav,\tv)))),$ \newline $\te' = \mathcal{K}_v(\mathcal{C}(\pi_{v_1,v_2,p} (\sigma_{C_{E1}}(\mathcal{N}_{v_1,v_2}(\te,\tae)) \bowtie_{v_1,v_2,p} \sigma_{C_{E2}}(\mathcal{N}_{v_1,v_2}(\tae,\te))), \tv')),$ \newline $\tav' = \mathcal{K}_v(\sigma_{C_{V2}}(\tav), \tv'),$ \newline $\tae' = \mathcal{K}_v(\sigma_{C_{E2}}(\tae), \tv')$ \\
Map & $map_{M_V,M_E}(\ttt)$ & $=$ & $\{ \tv, \te, \mathcal{C}(map_{M_V}(\tav)), \mathcal{C}(map_{M_E}(\tae) \} $ \\
Intersection & $\ttt_1 \cap^T_r \ttt_2$ & $=$ & $\tv' = \mathcal{C}(\mathcal{N}_v(\tv_1, \tv_2) \cap \mathcal{N}_{v}(\tv_2, \tv_1)),$ \newline $\te' = \mathcal{C}(\mathcal{N}_{v1,v2}(\te_1, \te_2) \cap \mathcal{N}_{v1,v2}(\te_2, \te_1)),$ \newline $\tav' = \mathcal{K}_v(\mathcal{C}(map_r(\mathcal{N}_v(\tav_1, \tav_2) \fullouterjoin_{v,p} \mathcal{N}_v(\tav_2, \tav_1))), \tv'),$ \newline $\tae' = \mathcal{K}_v(\mathcal{C}(map_r(\mathcal{N}_{v1,v2}(\tae_1, \tae_2) \fullouterjoin_{v_1,v_2,p} \mathcal{N}_v(\tae_2, \tae_1))), \tv')$ \\
Union & $\ttt_1 \cup^T_r \ttt_2$ & $=$ & $\tv' = \mathcal{C}(\mathcal{N}_v(\tv_1, \tv_2) \cup \mathcal{N}_{v}(\tv_2, \tv_1)),$ \newline $\te' = \mathcal{C}(\mathcal{N}_{v1,v2}(\te_1, \te_2) \cup \mathcal{N}_{v1,v2}(\te_2, \te_1)),$ \newline $\tav' = \mathcal{C}(map_r(\mathcal{N}_v(\tav_1, \tav_2) \fullouterjoin_{v,p} \mathcal{N}_v(\tav_2, \tav_1))),$ \newline $\tae' = \mathcal{C}(map_r(\mathcal{N}_{v1,v2}(\tae_1, \tae_2) \fullouterjoin_{v_1,v_2,p} \mathcal{N}_v(\tae_2, \tae_1))) \}$ \\
Difference & $\ttt_1 \setminus^T_r \ttt_2$ & $=$ & $\tv' = \mathcal{C}(\mathcal{N}_v(\tv_1, \tv_2) \setminus \mathcal{N}_{v}(\tv_2, \tv_1)),$ \newline $\te' = \mathcal{C}(\mathcal{N}_{v1,v2}(\te_1, \te_2) \cap \mathcal{N}_{v1,v2}(\te_2, \te_1)),$ \newline $\tav' = \mathcal{K}_v(\mathcal{C}(map_r(\mathcal{N}_v(\tav_1, \tav_2) \fullouterjoin_{v,p} \mathcal{N}_v(\tav_2, \tav_1))), \tv'),$ \newline $\tae' = \mathcal{K}_v(\mathcal{C}(map_r(\mathcal{N}_{v1,v2}(\tae_1, \tae_2) \fullouterjoin_{v_1,v_2,p} \mathcal{N}_v(\tae_2, \tae_1))), \tv')$ \\
Semijoin & $\ttt \ltimes_{C_V} \mathbf{r}$ & $=$ & \\
Aggregation & $\gamma_{C_V,C_E,A_V}(\ttt)$ & $=$ & \\
Node creation & $\vartheta_{W,Q_V,Q_E,A_V,A_E}(\ttt)$ & $=$ & \\
Composition & $\ttt_1 sym \ttt_2$ & $=$ & \\
\hline
\end{tabular}
\end{table*}

\eat{
When computing result of an operator over the \ve representation, we
do not require that each intermediate state of the data structure
correspond to a valid \tg, but rather that the final result, which is
usually derived after several steps, be valid.  To have a useful
algebra, we do not reject a change that would lead to a violation in
integrity.  Instead, we compute a consistent result by applying the
resolve, coalesce, and contrain primitives.
}
\eat{
Algorithm~\ref{alg:op} outlines the evaluation of a unary operation
\opp(\tve), overloading \opp as appropriate when applying the
operation to constituent parts of \tve.  Some of the steps in
Algorithm~\ref{alg:op} may be unnecessary because of the properties of
the particular operation, as we will see in the remainder of this
section.  Furthermore, 
}

%\begin{algorithm}[t]
%\caption{Evaluation of a unary operation \opp on \tve}
%\begin{algorithmic}[1]
%\REQUIRE \tg $\tve (\tv; \te; \tav; \tae)$, operation \insql{op}.\\
%\STATE  $\tv' = \cl (\opp(\tv))$\\
%\STATE  $\te' = \cl (\opp(\te))$\\
%\STATE  $\tav' = \cl (\opp(\tav))$\\
%\STATE  $\tae' = \cl (\opp(\tae))$\\
%\STATE  enforce foreign keys on $\te'$ w.r.t. $\tv'$\\
%\STATE  enforce foreign keys on $\tav'$ w.r.t. $\tv'$\\
%\STATE  enforce foreign keys on $\tae'$ w.r.t. $\te'$\\
%\RETURN new $\tve (\tv';\te';\tav';\tae')$\\
%\end{algorithmic}
%\label{alg:op}
%\end{algorithm}
