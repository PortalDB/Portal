\subsection{Use cases and algebra by example}
\label{sec:cases}

An interaction network is one typical kind of an evolving graph.  It
represents people as vertices, and interactions between them such as
messages, conversations and endorsements, as edges.  Information
describing people and their interactions is represented by vertex and
edge attributes.  One easily accessible interaction network is the
wiki-talk dataset (\url{http://dx.doi.org/10.5281/zenodo.49561}),
containing messaging events among Wikipedia contributors over a
13-year period.  Information available about the users includes their
username, group membership, and the number of Wikipedia edits they
made.  Messaging events occur when users post on each other's talk
pages.

We now present common analysis tasks that motivate the operators of
our algebra, \tga. \eat{ We are primarily interested in analyses of
  the evolution of the phenomena the graph represents, while also
  supporting simpler point queries.}

{\bf Vertex influence over time.} In an interaction graph, vertex
centrality is a measure of how important or influential people are.
Over a dozen different centrality measures exist, providing indicators
of how much information ``flows'' through the vertex or how the vertex
contributes to the overall cohesiveness of the network.  Vertex
importance fluctuates over time.  To see whether the wiki-talk graph
has high-importance vertices, and how stable vertex importance is over
time during a particular period of interest, we can look at a subset
of the graph that corresponds to the period of interest, compute an
importance measure, such as in-degree, for each vertex and for each
point in time, and finally calculate the coefficient of variation per
vertex.

\eat{This example demonstrates a need to select a subset of the data
corresponding to the period of interest, compute in-/out-degree for
each vertex at each point in time, and compute a single measure across
time for each vertex.  Computation of degree is a simple example of a
non-temporal {\em aggregation} operation as defined by the taxonomy of
Wood~\cite{Wood2012}.  Aggregation computes a value for each vertex
based on its neighbors and can be used for a wide variety of analyses.
SocialScope~\cite{Amer-Yahia2009} is one of the languages that proposes
an aggregation operation and demonstrates its many uses.  We introduce
a temporal version of aggregation.}

{\bf Question:} What are the high-influence nodes over the past 5
years, and is their influence persistent over time?

\begin{enumerate}[noitemsep,itemindent=\dimexpr\labelwidth+\labelsep\relax,leftmargin=0pt]
\item Select a subset of the data representing the 5 years of
  interest, using a common temporal operator slice($\tau$):\\
%
%\begin{center}
%\vspace{-0.2cm}
$\ttt_1 = \slice{[2010,2015)}{wikitalk}$
%\vspace{-0.2cm}
%\end{center}

\item Compute in-degree (prominence) of each vertex during each time
  point.  This is an example of the {\em aggregation} operation, a
  common operation on non-temporal graphs, as defined by the taxonomy
  of Wood~\cite{Wood2012}.  Aggregation computes a value for each
  vertex based on its neighbors.  SocialScope~\cite{Amer-Yahia2009} is
  one of the languages that proposes an aggregation operation and
  demonstrates its many uses.  We introduce a temporal version of
  aggregation (listed here with default arguments omitted for
  readability):\\
%
%\begin{center}
%\vspace{-0.2cm}
%$\ttt_2 = \agg{msg=(dst,p,1),red=count}{\ttt_1}$
$\ttt_2 = \insql{agg}^T(\mathsf{dir=right},\mathsf{f_m=1},\mathsf{f_a=count},\mathsf{pname=deg},\ttt_1)$
%\vspace{-0.2cm}
%\end{center}

\item Aggregate degree information per vertex across the timespan
  of $\ttt_2$, collecting values into a map.  This is an example of
  aggregation based on temporal window, which we implement with the
  temporal node creation operator:\\
%\begin{center}
%\vspace{-0.2cm}
$\ttt_3 =\insql{node}^T_w(\mathsf{w=lifetime},\mathsf{f_v=\{map(deg)\}},\ttt_2)$
%$\ttt_3 = \ncr{v}{W=lifetime,red=map(degree)}{\ttt_2}$
%\vspace{-0.2cm}
%\end{center}

\item Transform the attributes of each vertex to compute the
  coefficient of variation from the map of degree values, using the
  temporal vertex-map operator:\\
%\begin{center}
%\vspace{-0.2cm}
%$\ttt_4 = \map_{\mathsf{stdev(deg)/mean(deg)*100}}(\ttt_3)$
$\ttt_4 = \vmap{\mathsf{f_v=stdev(deg)/mean(deg)*100}, \ttt_3}$
%\vspace{-0.2cm}
%\end{center}
\end{enumerate}

{\bf Graph centrality over time.} Graph centrality is a popular
measure that is used to evaluate how connected or centralized the
community is.  This measure is computed by aggregating in-degree
values of graph vertices%~\cite{}.  Interestingly, centrality of a
graph may change as communication patterns evolve, or as high
influencers appear or disappear. In sparse interaction graphs there is
an additional question of temporal resolution to consider: if two
people communicated on May 16, 2010, how long do we consider them to
be connected?  We now show how graph centrality can be computed over
time, with control for temporal resolution.

\eat{This example demonstrates a need to compute graph centrality at every
point in its lifetime and to do so at different temporal resolution.
For most graph centrality measures, the two-step process involves
first calculating some measure, such as in-degree, for each graph
vertex, and then accumulating them into one.  This calls for an
operation that can group multiple vertices, in this case all of them,
into a new vertex.  Wood terms this operation {\em node creation} and
shows that many graph languages such as GraphQL~\cite{He2008} support
it if there is a need to output new nodes that were not part of the
input.  Creating a single vertex to represent the whole graph is one
way to support computation of some whole-graph measure, but, as we
show below, node creation is useful for other types of analyses.  Use
of temporal windows is also important here to consider different
temporal resolution, which is similar to temporal aggregation in
temporal relational databases.  Our temporal node creation operator
can create new nodes from structure or temporal information or both.}

{\bf Question:} How has graph centrality changed over time?

\begin{enumerate}[noitemsep,,itemindent=\dimexpr\labelwidth+\labelsep\relax,leftmargin=0pt]
\item Compute a temporally aggregated view of the graph into 2-months
  windows.  Each window will include vertices and edges that
  communicate frequently: a vertex and an edge are each present during
  a 2-month window if they exist in every snapshot during that period.
  We use the window-based node creation operation.\\
  % ($w=2~months$)%, with
%  vertex and edge existence quantifiers $q_v$ and $q_e$ set to
%  ``always''.
\eat{  Compute new vertices with temporal windows of a set size.  Use
  of temporal windows is used here to consider different temporal
  resolution, which is similar to temporal aggregation in temporal
  relational databases.  Our temporal node creation operator can
  create new nodes from structure or temporal information or both.  In
  the example above, we created new nodes to represent all of each
  node's history.  Here we use smaller temporal window, e.g. 2 months,
  and can vary that to investigate the effect of temporal resolution:}
%\begin{center}
%\vspace{-0.2cm}
%$\ttt_1 = \ncr{v}{W=2 months,Q_E=always}{wikitalk}$
$\ttt_1 = \insql{node}^T_w(\mathsf{w=2~mon},\mathsf{q_v=always},\mathsf{q_e=always},wikitalk)$
%\vspace{-0.2cm}
%\end{center}

\item Compute in-degree of each vertex:\\
%\begin{center}
%\vspace{-0.2cm}
%$\ttt_2 = \agg{msg=(dst,p,1),red=count}{\ttt_1}$
$\ttt_2 = \insql{agg}^T(\mathsf{dir=right},\mathsf{f_m=1},\mathsf{f_a=count},\mathsf{pname=deg},\ttt_1)$
%\vspace{-0.2cm}
%\end{center}

\item Create a new graph, in which all vertices that are present at a
  given time point (snapshot) are grouped into a single vertex.
  Accumulate maximum, sum and count of the values of $deg$ as
  properties at that vertex.  We implement this with the
  attribute-based node creation operation.  Creating a single vertex
  to represent the whole graph is one use of node creation.  We will
  show that node creation is useful for other types of analysis. $\ttt_3 =$\\
\eat{  Compute new vertex grouping all vertices co-existing in time
  into one, computing the sum, count, and max of degree.  For most
  graph centrality measures, the two-step process involves first
  calculating some measure, such as in-degree, for each graph vertex,
  and then accumulating them into one.  This calls for an operation
  that can group multiple vertices, in this case all of them, into a
  new vertex.  Wood terms this operation {\em node creation} and shows
  that many graph languages such as GraphQL~\cite{He2008} support it
  if there is a need to output new nodes that were not part of the
  input.  Creating a single vertex to represent the whole graph is one
  way to support computation of some whole-graph measure, but, as we
  show throughout, node creation is useful for other types of
  analyses.  }
%\begin{center}
%  \vspace{-0.2cm}
  %$\ttt_3 = \ncr{1}{red=max(deg)\&sum(deg)\&count(deg)}{\ttt_2}$
  $\insql{node}^T_a(\mathsf{g=1,f_v=\{max(deg),~sum(deg),~count(deg)\}},\ttt_2)$
%\vspace{-0.2cm}
%\end{center}

\item Compute degree centrality at each time point.\\
%\begin{center}
%\vspace{-0.2cm}
%$\ttt_4 = \map_{\mathsf{(max*count-sum)/(count^2-3*count+2)}}(\ttt_3)$
$\ttt_4 = \vmap{\mathsf{f_v=(max*cnt-sum)/(cnt^2-3*cnt+2)}, \ttt_3}$
%\vspace{-0.2cm}
%\end{center}

\end{enumerate}

{\bf Communities over time.} Interaction networks are sparse because
edges are so short-lived.  As part of exploratory analysis, we can
consider the network at different temporal resolutions, run a
community detection algorithm, e.g., compute the connected components
of the network, and then consider the number of and size of connected
components.

\eat{To see whether communities form and at what time scale, we can
  vary the time scale and compute communities, e.g. through connected
  components detection, group the vertices by the community they form
  and calculate their size.  We can filter out vertices that represent
  communities below a reasonable threshold, for example of size
  smaller than two.}

\eat{This example demonstrates a need to compute graph-wide analytics
  such as connected components for each point in time, create new
  vertices that represent some aspect of data of existing vertices,
  and compute subgraphs.  Graph-wide analytics on evolving graphs have
  been proposed previously in ImmortalGraph~\cite{Miao2015} and
  G*~\cite{Labouseur2015}, including PageRank, weakly connected
  components, and source-source shortest path.}

{\bf Question:} In a sparse communication network, on what time scale
can we detect communities?

\begin{enumerate}[noitemsep,itemindent=\dimexpr\labelwidth+\labelsep\relax,leftmargin=0pt]
\item Aggregate the graph into 6-month windows.\\
%  Compute new vertices with temporal windows of a set size:
%\begin{center}
%\vspace{-0.2cm}
%$\ttt_1 = \ncr{v}{W=6 months,Q_E=always,red=first(name)}{wikitalk}$
$\ttt_1 = \insql{node}^T_w(\mathsf{w=6~mon},\mathsf{q_v=always},\mathsf{q_e=always},wikitalk)$
%\vspace{-0.2cm}
%\end{center}

\item Compute connected components at each time point.  This is an
  example of a Pregel-style analytic invocation over an evolving
  graph. $\ttt_2 = \insql{pregel}^T_{cc} (\mathsf{pname=comp}, \ttt_1)$

  \eat{ We need to compute graph-wide analytics such as connected
    components for each point in time.  Graph-wide analytics on
    evolving graphs have been proposed previously in
    ImmortalGraph~\cite{Miao2015} and G*~\cite{Labouseur2015},
    including PageRank, weakly connected components, and source-source
    shortest path.}

%\begin{center}
%\vspace{-0.2cm}
%$\ttt_2 = \insql{pregel}^T_{cc} (\mathsf{pname=comp}, \ttt_1)$
%\vspace{-0.2cm}
%\end{center}

\item Generate a new graph, in which a vertex correspond to a
  connected component, and compute the size of the connected
  component. $\ttt_3 =
  \insql{node}^T_a(\mathsf{g=comp,f_v=count(1)},\ttt_2)$

%\begin{center}
%\vspace{-0.2cm}
%$\ttt_3 = \ncr{component}{W=1 change,red=count(name)}{\ttt_2}$
%$\ttt_3 = \insql{node}^T_a(\mathsf{g=comp,f_v=count(1)},\ttt_2)$
%\vspace{-0.2cm}
%\end{center}

\item Filter out vertices that represent communities too small to be
  useful (e.g., of 1-2 people).  This is an example of vertex
  subgraph.  $\ttt_4 = \subv{\mathsf{v.a.count > 2}}{\ttt_3}$
%\begin{center}
%\vspace{-0.2cm}
%$\ttt_4 = \subv{\mathsf{v.a.count > 2}}{\ttt_3}$
%\vspace{-0.2cm}
%\end{center}

\end{enumerate}

\eat{Besides the examples above, graph queries commonly include retrieving
a specific node (which can be accomplished through a subgraph) and
k-hop neighborhood of a node.  While general transitive closure
requires recursion, which we do not support, k-hop neighborhoods can
be computed using composition operations like the one defined in
SocialScope~\cite{Amer-Yahia2009}.  We provide temporal versions of
subgraph and generalized edge creation.  Additionally, if multiple
sources of the same graph are available, it is useful to combine or
compare them, which dictates the need for temporal set-theoretic
operators.}

In Section~\ref{sec:algebra} we formally define the operators of our
graph algebra.  In Section~\ref{sec:exp} we return to these three use
cases. 
