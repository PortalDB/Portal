\section{Algebra}
\label{sec:algebra}
\setlength{\textfloatsep}{5pt}% Remove \textfloatsep

\tg algebra, or \tga for short, is compositional: operators take a \tg
or a pair of \tgs as input, and output a \tg.  We specify the
semantics of \tga by showing a translation of each operator into a
sequence of temporal relational algebra (TRA) expressions.  Using this
translation one can implement \tga in a temporal RDBMS, guranteeing
snapshot reducibility and extended snapshot
reducibility~\cite{DBLP:reference/db/Bohlen092} --- two properties
that are appropriate for a point-based temporal data model.

In Section~\ref{sec:algebra:integrity} we present the primitives that
are needed to enforce soundness of \tga.  Then, in
Sections~\ref{sec:algebra:unary} through~\ref{sec:algebra:ecreate}, we
present \tga operators.  Section~\ref{sec:analytics} presents an
extension of \tga to support Pregel-style analytics.  We conclude by
showing expressiveness of \tga in Section~\ref{sec:algebra:formal}.

\subsection{Soundness}
\label{sec:algebra:integrity}

In the remainder of this setion, we will present a translation of
every \tga operator into a sequence of expressions in temporal
relational algebra (TRA).  Since TRA is applied to individual
relations of \tve, we must ensure that the combined state of these
relations in the result corresponds to a valid \tg, i.e., that the
translation is sound.  Returning to Definition~\ref{def:tg}, we
observe that relations of \tve must meet the following requirements;

\begin{description}[noitemsep]

\item [R1 No duplicates] In every snapshot of $\tau^s_c (\tv)$ and
  $\tau^s_c (\te)$ a vertex/edge exists at most once at any time
  point. (Clauses~\ref{def:tg:c2} and~\ref{def:tg:c3} of
  Definition~\ref{def:tg}.)

\item [R2: Coalesced] Value-equivalent tuples in all relations of \tv
  with consecutive or overlapping time periods are
  merged. (Clauses~\ref{def:tg:c2} and~\ref{def:tg:c3} of
  Definition~\ref{def:tg}.)

\item [R3: Referential integrity] Foreign key constraints hold from
  \te and \tav to \tv, and from \tae to \te.
  (Clauses\\~\ref{def:tg:c1},~\ref{def:tg:c5}, and~\ref{def:tg:c7} of
  Definition~\ref{def:tg}.)

\item [R4: Single attribute] Every vertex/edge has at most one
  attribute (property set) at any time. (Clauses\\\ref{def:tg:c4} and
  ~\ref{def:tg:c6} of Definition~\ref{def:tg}.)
  
\end{description}
\vspace{-1ex}

To enforce requirements {\bf R1} and {\bf R2}, we introduce the
coalesce primitive $\coal{r}$, which merges adjacent or overlapping
time periods for value-equivalent tuples.  This operation is similar
to duplicate elimination in conventional databases, and has been
extensively studied in the
literature~\cite{DBLP:conf/vldb/BohlenSS96,DBLP:journals/sigmod/Zimanyi06}.
$\coal{r}$ is applied to individual relations of \tve following the
application of operations that uncoalesce.  Note that if a DBMS
supports automatic coalescing, this primitive is not necessary.  Note
also that eager coalescing is not always desirable, since it is
expensive and some operations may produce correct results (up to
coalescing) even when computing over uncoalesced inputs.  We will
revisit this point in Section~\ref{sec:sys:coal}.

\julia{Refrentian integrity is always by key.  There is not need to
  give $k$ as an argument.}

To enforce {\bf R3} we introduce the constrain primitive
$\constr{k}{r}{s}$, which enforces referential integrity on relation
$\mathbf{r}$ with respect to relation $\mathbf{s}$.% by key mapping
$k$.  For example, this primitive is used to remove edges from \te for
which one or both vertices are absent from \tv, and to trim he edge
validity period to be within the validity periods of associated
vertices. \julia{Does this latter case arise?}

To enforce {\bf R4} we require that every operator that may produce
multiple possible values for the same vertex or edge property at a
time point $c$ accept a user-specified {\em reduce} function
$\mathbf{red}$, defined below.

\julia{Do we need period to be part of the resolve function?  If so,
  what is the default behavior?  And how does one compute, e.g., a
  union of the periods if they are not adjacent?  Generally, it's not
  clean to allow explicit manipulation of timestamps in a temporal
  model - it's OK to refer to them in the where clause, but not to
  compute them, because that changes model expressiveness drastically
  --- you can specify an arbitrary function that ``creates time''.}

\begin{definition}[Reduce function]
Let $((a_l,p_l),(a_r,p_r))$ be a pair of possible values of a property
of a vertex or an edge, along with the associated validity periods.  A
{\em reduce function} produces a single property value with its
validity period $(a,p) = red((a_l,p_l), (a_r,p_r))$.
\end{definition}

The reduce function may, for example, pick the left, the right, or an
arbitrary element, compute the value of an aggreagte function such as
$\mathbf{COUNT}$, or accumulate values into a set.  A reduce function
can be repeatedly applied to an unordered collection of values to
compute a single value, as is done in the map-reduce model.  The
property graph model allows for arbitrary properties to be associated
with the graph entities, so it may be impractical or infeasible to
have the user specify a reduce function for each possible property.
In \ql a default reduce function \insql{set} is used for any property
without an explicitly stated reduction.

\eat{\begin{lemma}
Let $\psi$ be an n-ary temporal operator on \tg.  If $\psi^T (\ttt)$
produces multiple possible attribute values for any entity at the same
time instant, it must also specify a resolve function for each
property to compute a single valid attribute value.
\end{lemma}}

\eat{In operator definitions below we note which operators are known to
uncoalesce the output, thus requiring coalescing, require FK
enforcement, or include reduce functions.  All non-trivial proofs are
listed in Appendix~\ref{sec:app1}.}

\subsection{Unary operators}
\label{sec:algebra:unary}

%We now introduce unary operators slice, subgraph and map.

{\bf Slice.}  The slice operator, denoted $\slice{\bc}{\ttt}$, where
$\bc$ is a time interval, cuts a temporal slice from \ttt. The
resulting \tg will contain vertices and edges whose period $\bp$ has a
non-empty intersection with $\bc$: $\slice{\bc}{\tv} = \{ (v, \bp \cap
\bc)~~|~~(v, \bp) \in \tv \wedge (\pred{\bc}{overlaps}{\bp} \vee
\pred{\bc}{contains}{\bp}) \}$, and analogously for each \te, \tav and
\tae.  To evaluate $\slice{\bc}{\ttt}$, we apply select operator to
each of the four constituent relations of \tve: $\forall x \in
\{\tv,\te,\tav,\tae \}, x' = \pi_{A,p \cap c}(\sigma_{p \cap c} (x))$,
where $A$ is the non-temporal schema of $x$.

\eat{If $p.start < c.start$ or $p.end > c.end$ for some tuple $(g,
  p)$, then $p$ is trimmed to be within the boundaries of $c$: $\tau_c
  (\trg) = \{ (g, p \cap c)~~|~~(g, p) \in \trg \wedge
  (\pred{c}{overlaps}{p} \vee \pred{c}{contains}{p})\}$.  }

Slice does not violate any of the four conditions: it does not produce
duplicates, does not uncoalesce any of the \tve relations, does not
violate FK enforcement, and does not produce multiple values for a
vertex or edge attribute.

%\subsection{Temporal subgraph matching}
%\label{sec:algebra:subgraph}

{\bf Subgraph.}  Temporal subgraph matching is a generalization of
subgraph matching for non-temporal graphs~\cite{Wood2012}.  This query
comes in two variants.

\eat{A temporal vertex-subgraph query $q^T_v(\tve)$ is a conjunctive query
that takes $\tve (\tv, \te, \tav, \tae)$ as input, and outputs
$\tve'$, an induced temporal subgraph of \tve in which vertices are
defined by $q^T_v$.}

A temporal vertex-subgraph operator \subv{q}{\ttt} outputs an induced
subgraph of \ttt where vertices are defined by a temporal conjunctive
query (TCQ) $q$.  Note that this is a subgraph query, and so no new
vertices are created, i.e., $\tv' \subseteq \tv$.  As long as $q$ is a
valid temporal conjunctive query over the four relations of \tve and
returns vids, the output is guaranteed to be a valid subset of \tv.

\eat{A temporal edge-sugraph query $q^t_e(\tve)$ is a conjunctive query
that takes a graph $\tve (\tv, \te, \tav, \tae)$ as input, and outputs
a \tg $\tve'$ on the vertices of $\tve$ such that the edges of $\tve'$
are defined by $q^t_e$. }

A temporal edge-subgraph operator \sube{q}{\ttt} outputs a subgraph of
\ttt where edges are defined by TCQ $q$.  Since this is a subgraph
query, no new edges are created, i.e., $\te' \subseteq \te$.

Queries $q^t_v$ and $q^t_e$ may include predicates over any of the
consitutent relations of \tve to compute the vertex (resp. edge) sets.
Further, these queries may explicitly reference temporal information,
and so require that all temporal relations over which they operate be
coalesced~\cite{DBLP:reference/db/Bohlen09}. 

\eat{We focus on functions that can be expressed as a pair of {\em
  conjunctive queries} $\sigma_{C_V,C_E} (\ttt)$, where $C_V$
specifies a predicate over the vertices and $C_E$ --- over the
vertex-edge triplets.  The predicates can be over the attributes, ids,
and the timestamps of the vertices and edges.  We allow predicates
over the timestamps to support extended snapshot reducibility.
Computing arbitrary subgraphs with path expressions is beyond the
scope of this paper, and we defer this to future work.}

\eat{
$\sigma_{C_V,C_E} (\ttt) = (\tv',\te',\tav',\tae') ~|~$ \\
$\tv' = \pi_{v,p} (\sigma_{C_V} ( \tv \bowtie^T_v \tav))$ \\
$\te' = \pi_{v_1,v_2,p} (\sigma_{C_E} ( \tae \bowtie^T_{v_1} \tav \bowtie^T_{v_2} \tav))$ \\
$\tav' = \sigma_{C_V} (\tav)$ \\
$\tae' = \pi_{v_1,v_2,a} (\sigma_{C_E} (\tae \bowtie^T_{v_1} \tav \bowtie^T_{v_2} \tav))$}

\eat{ Note that as B{\"{o}}hlen showed
  in~\cite{DBLP:reference/db/Bohlen09}, correctness of a select
  operator with a temporal predicate depends on the coalesced state of
  the relation.  When composing a triplet, we carry the vertex and
  edge timestamps in their entirety as data to produce correct
  results.}

% There is no need for an example here, it is clear what these queries
% compute.

\eat{Because we allow predicates over the triplets, interesting conditions
can be expressed.  For example, we can filter out any edges where the
value of some property of its two vertices does not match.  Assuming
vertices have property \insql{group}, we can compute
$\sigma_{T,v1.a.group=v2.a.group}(\ttt)$.}

Vertex-subgraph: {\bf R1,R2}: coalesce $\tv'$; {\bf R3}: enforce FK on
$\tav', \te', \tae'$. Edge-subgraph: {\bf R1,R2}: coalesce $\te'$;
{\bf R3}: enforce FK on $\te'$ and $\tae'$.

\eat{Vertex-subgraph requires coalescing of $\tv'$ and FK enforcement on
\tav', \te', and \tae'. Edge-subgraph requires coalescing of $\te'$ and
FK enforcement on \tae'.}

%\subsection{Temporal map}
%\label{sec:algebra:project}

{\bf Map.}  Temporal vertex-map and edge-map operations apply
user-defined map functions to vertex or edge attributes.  Temporal
vertex-map $\vmap{\tve}$ outputs $\tve'$ in which $\tv'=\tv$,
$\te'=\te$, $\tae' = \tae$, and $\tav' = \vmap{\tav}$.  Temporal
edge-map is defined analogously.

\eat{To evaluate $\map_{M_V,M_E} (\tve)$, we set $\tv'=\tv$ and $\te'=\te$,
and compute $\tav' = \map_{M_V}(\tav)$ and $\tae' = \map_{M_E}(\tae)$.}

\eat{Temporal map iterates over the tuples of \trg, and applies the
user-specified map functions $M_V$ and $M_E$ to the vertices and edges
of each $g$: $\map_{M_V,M_E} (\trg) = \{(g', p)~~|~~(g,p) \in \trg
\wedge g'= \map_{M_V,M_E}(g)\}$.
}  

While temporal map is an arbitrary user-specified function, there are
some common cases.  Map may be used to specify the set of properties
to project out or retain, to aggregate (e.g., \insql{COUNT}) or
deduplicate values in a list property, or to flatten a nested
property value.

% because this is an arbitrary operation, we don't need to invent
% syntax here.  it's also clear what this operation does, I don't
% think there is a need for an example.

\eat{In such cases we will use short-hand
notation similar to projection, listing the properties that we wish to
retain. For example, $\map_{M_V:{school},M_E:\emptyset} (\insql{T1})$
will keep only the school property of the vertices, and no properties
of the edges.  Another useful map operation eliminates duplicates in
the bag of a particular vertex or edge property.  \eat{It may also be
useful to flatten nested bags or aggregate multiple values of the same
property of a vertex or edge, e.g., compute a sum or an average
following temporal intersection or union
(Section~\ref{sec:algebra:join}).}}

Vertex-map: {\bf R2}: coalesce $\tav'$.  Edge-map: {\bf R2}: coalesce
$\tae'$.

\eat{Vertex-map requires only coalescing of $\tav'$. Edge-map requires
  only coalescing of $\tae'$.}

\subsection{Aggregation}
\label{sec:algebra:agg}

Aggregation is a common graph operation that can be used to compute
simple properties such as in-degrees of vertices or more complex ones
such as a set of places that all close friends have visited in the
past year.  Aggregation is denoted $\agg{cond,msg,red}{\ttt}$, where
$cond$ is a predicate over the edge triplet, i.e. over the attributes
of the edge and its two vertices, $msg$ is a function that takes in a
triplet and produces a $(v,p,m)$ key-value message $m$ to vertex $v$
at triplet time $p$, and $red$ is a reduce function.  The result is a
new isomorphic graph $\ttt'$: $\agg{cond,msg,red}{\ttt} = \{ \tv,
\te, \tav', \tae \}$, where $\tav' = \pi^T_{v,a_1+a_2}(\tav
\bowtie^T_v$ \\ $_v\vartheta^T_{red} (msg (\sigma_{cond} (\tae
\bowtie^T_{v_1=v} \tav \bowtie^T_{v_2=v} \tav))))$.  The temporal join
is used to add the new properties to the output since it may have
different periods of validity.  For example, while each vertex in \tg
may remain unchanged for the whole duration, aggregating vertex
degrees would result in an attribute value for each period of topology
change.

We support various reduce functions, including the standard \{
\insql{count} | \insql{min} | \insql{max} | \insql{sum} \}, which have
their customary meaning.  We also support \{ \insql{any} |
\insql{first} | \insql{last} | \insql{set} | \insql{list} \}, which
are possible to compute because properties being reduced have temporal
information.  \insql{first} and \insql{last} refer to the value of an
property with the earliest/latest timestamp, while \insql{set} and
\insql{list} associate a key with an unordered collection of values
with the set or bag semantics (but do not keep the associated validity
periods).  Other, more complex, functions can be defined by the user.
\insql{set} is the default reduce function.

As an example, to compute vertex in-degrees, we can use
$\agg{msg=(dst,p,1),red=count}{\ttt}$.  To compute a set of places
that all close friends have visited in the past year, assuming there
is a property \insql{places} on friend vertices and closeness of
friendship property on edges:\\ $\agg{cond=dst.p \cap [2015,2016) \&
    a.close > 0.8,msg=(src,p,dst.places)}{\ttt}$.

{\bf R2}: coalesce $\tav'$; {\bf R4}: require reduce function.

\eat{Aggregation requires coalescing of $\tav'$.}

\subsection{Binary set operators}
\label{sec:algebra:binary}

We support the temporal versions of the three binary set operators
intersection ($\cap^T$), union ($\cup^T$), and difference
($\setminus^T$).  As Dignos et al. showed, the three set operators are
not schema robust~\cite{Dignos2012}.  Schema robust operators are not
affected if the argument relation is extended by an additional
attribute.  This presents a problem when executing the set operations
over the \tav and \tae relations as there is no guarantee that a
vertex or an edge with the same identity and at the same time instant
has the same attribute set.  Thus all three operators require reduce
functions.

Let $\oplus$ be a temporal set operator $\in \{ \cap^T, \cup^T,
\setminus^T \}$ and $red$ be a set of reduce functions.  Then $\tve_1
\oplus_{red} \tve_2 = \{ \tv_1 \oplus \tv_2, \te_1 \oplus \te_2,
\pi^T_{v,red(a_1,a_2)}(\tav_1 \fullouterjoin^T_{v}
\tav_2),$\\ $\pi^T_{v_1,v_2,red(a_1,a_2)}(\tae_1
\fullouterjoin^T_{v_1,v_2} \tae_2) \}$, with all FK constraints on
\tav and \tae enforced.

As elsewhere, the default reduce function is \insql{set}.  In addition
to the functions defined in Section~\ref{sec:algebra:agg} we also
support \{ \insql{left} | \insql{right} \}, which select the attribute
of the left, resp. right, operand.

%\subsection{Temporal graph intersection}
%\label{sec:algebra:join}
\eat{
The binary temporal graph intersection operation $\trga \cap \trgb$
computes a temporal join~\cite{Gao2005} of \trga and \trgb with the
predicate $\trga.p \cap \trgb.p \neq \emptyset$, producing a tuple for
each pair of representative graphs for which time periods intersect:
$\trga \cap \trgb = \{(g_1 \cap g_2, p_1 \cap p_2)~|~((g_1, p_1) \in
\trga \wedge (g_2, p_2) \in \trgb \wedge p_1 \cap p_2 \neq \emptyset
\}$.  The result of $g_1 \cap g_2$ is computed by intersecting the
sets of vertices and of edges of the graphs~\cite{GraphTheory}.  For
each vertex and edge in the result, we compute a {\em union} of their
bags of properties.% \julia{Figure with example.}
%
Algorithm~\ref{alg:inter} presents the evaluation of $\tvea \cap
\tveb$. We compute temporal joins over \tv and \te (lines 1, 2).  We
then compute \tav' and \tae' with temporal outer joins of the
corresponding relations (lines 3, 4).  Finally, we enforce foreign key
constraints on \te', \tav' and \tae' (lines 5, 6).
}

%\begin{algorithm}[b]
%\caption{Temporal graph intersection in \tve.}
%\begin{algorithmic}[1]
%%\REQUIRE $\tvea (\tv_1;\te_1;\tav_1;\tae_1), \tveb (\tv_2;\te_2;\tav_2;\tae_2)$.\\
%\REQUIRE $\tvea, \tveb$.\\
%\STATE $\tv' = \tv_1 \Join^T_v \tv_2$\\ 
%\STATE $\te' = \te_1 \Join^T_{v_1,v_2} \te_2$\\ 
%\STATE $\tav' = \cl (\pi_{v,p,\tav_1.a \cup \tav_2.a}\tav_1 \fullouterjoin^T_v \tav_2)$\\
%\STATE $\tae' = \cl (\pi_{v_1,v_2,p,\tae_1.a \cup \tae_2.a}\tae_1 \fullouterjoin^T_{v_1,v_2} \tae_2)$\\
%\STATE $\tae' = \pi_{a_1 \cap a_2}(\tae_1 \Join^T \tae_2)$\\
%\STATE enforce foreign keys on $\tav'$ w.r.t. $\tv'$\\ 
%\STATE enforce foreign keys on $\tae'$ w.r.t. $\te'$\\ 
%\RETURN new $\tve (\tv';\te';\tav';\tae')$\\
%\end{algorithmic}
%\label{alg:inter}
%\end{algorithm}

\begin{figure*}
%\centering
\begin{subfigure}{2.5in}
\includegraphics[width=2.5in]{figs/T2_rel.pdf}
\caption{T2.}
\label{fig:tg_t2}
\end{subfigure}
\begin{subfigure}{4.3in}
\includegraphics[width=4.3in]{figs/T1_union_T2_rel.pdf}
\caption{$T1 \cup^T T2.$}
\label{fig:tg_union}
\end{subfigure}
\begin{subfigure}{2.3in}
\includegraphics[width=2.3in]{figs/T1_inter_T2_rel.pdf}
\caption{$T1 \cap^T T2$.}
\vspace{-0.2cm}
\label{fig:tg_inter}
\end{subfigure}
\begin{subfigure}{2.3in}
\includegraphics[width=2.3in]{figs/T1_diff_T2_rel.pdf}
\caption{$T1 \setminus^T T2$.}
\vspace{-0.2cm}
\label{fig:tg_diff}
\end{subfigure}
\caption{Binary operators.}
\label{fig:binary}
\vspace{-0.2cm}
\end{figure*}

Figure~\ref{fig:tg_inter} illustrates temporal intersection of \tg T2,
shown in Figure~\ref{fig:tg_t2}, with T1 in our running example, with
a set reduce function for all properties.  Period $[2/15, 4/15)$ for
  $v_2$ is computed as a result of the join of $[2/15, 5/15)$ in T1
    and [$2/15, 4/15)$ in T2.  Only the vertices and edges present in
      both \tgs are produced, thus eliminating $v_3$ and $v_4$.
      Figure~\ref{fig:tg_union} is similar to
      Figure~\ref{fig:tg_inter} but using union instead of
      intersection.  According to the definition of temporal set
      union, periods are split to coincide for any group and thus the
      attribute values for e.g. $v_1$ now have three distinct tuples.
      Figure~\ref{fig:tg_diff} is a result of temporal difference of
      T1 and T2.  Vertex $v_1$ is now present before $2/15$ and after
      $6/15$, which splits the a single input tuple into multiple
      disjoint ones.

{\bf R1, R2}: for all set operators coalesce every relation in
$\ttt'$; {\bf R3}: enforce FK on $\tav'$ and $\tae'$ for difference,
intersection. {\bf R4}: require reduce function.

\eat{Intersection and union may uncoalesce, while difference does not.
  Intersection and difference require FK enforcement for \tav and
  \tae, while union does not.}

%\subsection{Temporal graph union}
%\label{sec:algebra:outerjoin}

\eat{
The binary temporal graph union operation $\trga \cup \trgb$ computes
a temporal full outer join~\cite{Gao2005} of \trga and \trgb on the
predicate $\trga.p \cap \trgb.p $. For tuples $(g_1, p_1) \in \trga$
and $(g_2, p_2) \in \trgb$ for which $p_1 \cap p_2 \neq \emptyset$, we
compute $(g_1 \cup g_2, p_1 \cap p_2)$.  The result of $g_1 \cup g_2$
is computed by taking a {\em union} of the sets of vertices and of
edges of the graphs~\cite{GraphTheory}.  For each vertex and edge in
the result, we compute a {\em union} of their bags of properties.
Tuples from \trga (resp. \trgb) for which there does not exist a tuple
in \trgb (resp. \trga) for part or all of the validity period are
included in the result of the full outer join. 
}

\eat{
 $\trg_1 \cup \trg_2 = \{ (g, p) | (g_1, p_1) \in \trg_1 \wedge (g_2,
p_2) \in \trg_2 \wedge ((g = g_1 \cup g_2 \wedge p = p_1 \cap p_2
\wedge p_1 \cap p_2 \neq \emptyset) \vee (g = g_1 \wedge p = p_1 - p_2
\wedge \nexists p \in \trg_2 = p_1 - p_2) \vee (g = g_2 \wedge p = p_2
- p_1 \wedge \nexists p \in \trg_1 = p_2 - p_1))\}$.  Similar to
temporal intersection, temporal union is essentially an outer
theta-join of $\trg_1$ and $\trg_2$ with a $p_1 \cap p_2$ predicate.
We use the standard graph union definition based on set theory, which
computes unions of the vertex and edge sets from the two
operands~\cite{GraphTheory}.}

\eat{
Algorithm~\ref{alg:union} presents the evaluation of $\tvea \cup
\tveb$.  We compute temporal outer joins over the corresponding \tv,
\te, \tav and \tae.
}

\eat{\begin{algorithm}[t]
\caption{Temporal graph union in \tve.}
\begin{algorithmic}[1]
\REQUIRE $\tvea, \tveb$.\\
\STATE $\tv' = \tv_1 \fullouterjoin^T_v \tv_2$\\
\STATE $\te' = \te_1 \fullouterjoin^T_{v1,v2} \te_2$\\
\STATE $\tav' = \cl (\pi_{v,p,\tav_1.a \cup \tav_2.a}\tav_1 \fullouterjoin^T_v \tav_2)$\\
\STATE $\tae' = \cl (\pi_{v_1,v_2,p,\tae_1.a \cup \tae_2.a}\tae_1 \fullouterjoin^T_{v1,v2} \tae_2)$\\
\RETURN new $\tve (\tv';\te';\tav';\tae')$\\
\end{algorithmic}
\label{alg:union}
\end{algorithm}
}

%\subsection{Temporal graph difference}
%\label{sec:algebra:diff}

\eat{
The binary temporal graph difference operation $\trga \setminus \trgb$
computes a temporal left outer join~\cite{Gao2005} of \trga and \trgb
on the predicate $\trga.p \cap \trgb.p$.  For tuples $(g_1, p_1) \in
\trga$ and $(g_2, p_2) \in \trgb$ for which $p_1 \cap p2 \neq
\emptyset$, we compute $(g_1 \setminus g_2, p_1 \cap p_2)$.  The
result of $g_1 \setminus g_2$ is computed by taking a {\em set
  difference} of the sets of vertices and of edges of the graphs.  For
each vertex and edge in the result, we compute a {\em union} of their
bags of properties.  Tuples in \trga for which there does not exist a
tuple in \trgb for part or all of the validity period are included in
the result of the left outer join.
}
\eat{
Algorithm~\ref{alg:diff} presents the evaluation of $\tvea \setminus
\tveb$.  We compute temporal left outer joins over the corresponding
\tv and \te (lines 1,2).  We then compute $\tav'$ and $\tae'$ with
temporal outer joins of the corresponding relations (lines 3, 4).
Finally, we enforce foreign key constraints on $\te'$, $\tav'$, and
$\tae'$ (lines 5, 6).
}

\eat{\begin{algorithm}[b]
\caption{Temporal graph difference in \tve.}
\begin{algorithmic}[1]
\REQUIRE $\tvea, \tveb$.\\
\STATE $\tv' = \tv_1 \leftouterjoin^T_v \tv_2$\\ 
\STATE $\te' = \te_1 \leftouterjoin^T_{v_1,v_2} \te_2$\\ 
\STATE $\tav' = \cl (\pi_{v,p,\tav_1.a \cup \tav_2.a}\tav_1 \fullouterjoin^T_v \tav_2)$\\
\STATE $\tae' = \cl (\pi_{v_1,v_2,p,\tae_1.a \cup \tae_2.a}\tae_1 \fullouterjoin^T_{v_1,v_2} \tae_2)$\\
\STATE enforce foreign keys on $\tav'$ w.r.t. $\tv'$\\ 
\STATE enforce foreign keys on $\tae'$ w.r.t. $\te'$\\ 
\RETURN new $\tve (\tv';\te';\tav';\tae')$\\
\end{algorithmic}
\label{alg:diff}
\end{algorithm}
}

\subsection{Node creation}
\label{sec:algebra:ncreate}

We argued in the introduction that it is interesting and insightful to
analyze an evolving graph at different levels of granularity.  For
example, the user may want to aggregate multiple consecutive
representative graphs into a single representative graph, coarsening
the granularity, or to predefine temporal resolution and look at the
graph at that scale, irrespective of whether this resolution happens
to be finer or coarse than the natural evolution rate of the graph.
For this, we introduce a node creation operator which is similar to
the {\em moving window temporal aggregation} in temporal relational
algebra.  Our approach is inspired by stream aggregation work
of~\cite{Li2005}, adopted to graphs, and by generalized quantifiers
of~\cite{Hsu1995}.

Node creation is denoted $\ncr{G_V}{W,Q_V,Q_E,red}{\ttt}$,\\ where
$G_V$ are the grouping attributes, $W$ is the window specification,
$Q_V$ and $Q_E$ are vertex and edge quantifiers, and $red$ is the set
of reduce functions.  It produces a consolidated evolving graph with
specific temporal granularity.

{\em Grouping attributes} $G_V$ are vertex properties by which
vertices are grouped into new entities, similar to \insql{GROUP BY}
clause in SQL.  Since node creation requires new identifiers, the
combination of the grouping properties can be used in a mechanism
equivalent to a Skolem function.  The simplest, default grouping
attribute is the $vid$ of the vertex.

{\em Window specification} $W$ is of the form
$n~\{unit|\insql{changes}\}$, where $n$ is an integer, and $unit$ is a
time unit, e.g., $10~min$, $3~years$, or any multiple of the usual
time units.  Window specification of the form $n~\insql{changes}$
defines the window in terms of change over \trg.\eat{ (which may be
  computed from the \tve representation, see
  Section~\ref{sec:model:switch}).}  For example,
$W=3~\insql{changes}$ will aggregate sequences of 3 representative
graphs into 1.  Window boundaries are computed left-to-right, i.e.,
from least to most recent.  The right-most window may correspond to
fewer than $n$ representative graphs from the input.
%
Our window specification by change is similar to slide-by-row window
in stream aggregation~\cite{Li2005}.  Note that, because \tg algebra
is compositional, we do not support node creation with overlapping
windows, because it does not produce a valid \tg.  To see why this is
so, consider applying a sliding window of 3 months range with 1 month
slide to graph \insql{T} in Figure~\ref{fig:tg_rg}.  We would produce
the following tuples for $v_1$: $(v_1, [1/15, 4/15), a_1)$, $(v_1,
  [2/15, 5/15), a_2)$, $(v_1, [3/15, 6/15))$, and so on, which clearly
      violates the temporally coalesced requirement in
      definition~\ref{tg}.

Similar to~\cite{Li2005} we support creation simultaneously by time
and by non-temporal attributes (e.g., vertex properties).  If the
window specification is one change, then the operation devolves into
pure structural reduce or node creation, as classified by
Wood~\cite{Wood2012}.  If the grouping attribute is the vertex $vid$,
then the operation is purely temporal, with no structural aspect.

{\em Quantifiers} $Q_V$ and $Q_E$ are of the form \{ \insql{all} |
\insql{most} | \insql{at least} $n$ | \insql{exists} \}, where $n$ is
a decimal representing the percentage of the time during which an
entity (vertex or edge) existed, relative to the duration of the
window. Note that \insql{exists} is the default quantifier for
vertices and edges.  Quantifiers are useful for producing different
kinds of representative graphs.  For example, to produce
representative graphs with only strong connections over a volatile
evolving graph, we may want to only include vertices that span the
entire time window ($Q_V=\insql{all}$), and edges that span a large
portion of the window ($Q_E=\insql{most}$).
 
The optional reduce functions compute new
values for vertex and edge properties representative of
the whole window, e.g., $any(name), last(school), sum(cnt)$.
%
 
\eat{Key-value pairs for vertex and edge properties for which no
aggregation functions are specified, are collected into a bag
corresponding to the entity in the result.  These can be subsequently
transformed with $map^T$ (Section~\ref{sec:algebra:project}).}

\eat{ 
Temporal aggregation over \tve follows the outline of
Algorithm~\ref{alg:op}, but requires an additional step, and is
revisited in Algorithm~\ref{alg:agg_ve}.
%
}

We compute group periods based on window specification: $P =
\textsf{computePeriods}(W, \tv, \te, \tav, \tae)$.  We use temporal
aggregation and selection to evaluate $Q_V$ on each group in $\tv$:
$\tv' = \sigma_{P,Q_V}( _{G_V}\vartheta^T (\tv \leftouterjoin^T
\tav))$ and similarly for $\te$: $\te' = \sigma_{P,Q_E}(
_{G_V}\vartheta^T (\te \bowtie^T_{v_1=v} \tav \bowtie^T_{v_2=v}
\tav))$.  The edge triplets, obtained through three-way temporal join
of \tae with \tav are required to aggregate edges by $G_V$.  To
compute attribute relations we compute temporal aggregation with the
reduce functions and enforce FK constraints: $\tav' =
~_{G_V}\vartheta^T_{red}(\tav)$, $\tae' =
~_{G_V}\vartheta^T_{red}(\tae \leftouterjoin^T_{v_1=v} \tav
\leftouterjoin^T_{v_2=v})$.

\eat{
Node creation over \trg is computed by first calculating time periods
from $W$ and \trg, and then reducing and combining the representative
graphs directly.
}

\eat{\begin{algorithm}[t!]
\caption{Node creation in \tve.}
\begin{algorithmic}[1]
\REQUIRE \tve (\tv;\te;\tav;\tae), window specification $W$, vertex
quantifier $Q_V$, edge quantifier $Q_E$, vertex aggregate function
$A_V$, vertex aggregate function $A_E$.\\
\STATE $P = \textsf{computePeriods}(W, \tv, \te, \tav, \tae)$\\
\STATE  $\tv' = \cl (_{G_V}\vartheta_{P,Q_V}(\tv))$\\
\STATE  $\te' = \cl (_{G_V}\vartheta_{P,Q_E}(\te))$\\
\STATE  $\tav' = \cl (_{G_V}\vartheta_{P,A_V}(\tav))$\\
\STATE  $\tae' = \cl (_{G_V}\vartheta_{P,A_E}(\tae))$\\
\STATE  follow steps 5-7 of Algorithm~\ref{alg:op}\\
%\STATE  enforce foreign keys on $\te'$ w.r.t. $\tv'$\\
%\STATE  enforce foreign keys on $\tav'$ w.r.t. $\tv'$\\
%\STATE  enforce foreign keys on $\tae'$ w.r.t. $\te'$\\
\RETURN new $\tve (\tv';\te';\tav';\tae')$\\
\end{algorithmic}
\label{alg:agg_ve}
\end{algorithm}
}

Figure~\ref{fig:tg_agg1} illustrates node creation by time
($W=3~\textsf{months}$), and Figure~\ref{fig:tg_agg2} --- by change
($W=3~\textsf{changes}$).  Figure~\ref{fig:tg_agg3} illustrates
structural reduce only ($W=1~\textsf{change}$), and
Figure~\ref{fig:tg_agg4} both structural and temporal
($G_V=\textsf{school}, W=3~\textsf{months}$).  All four are applied to
\insql{T1} in our running example, and list the same quantifiers
(\insql{all} for vertices and \insql{exists} for edges) and reduce
functions (\insql{first} for vertex and edge properties).  $v_2$ is
present in the result in Figure~\ref{fig:tg_agg1} starting at $4/15$
because it did not exist for the entirety of the first window, while
in Figure~\ref{fig:tg_agg2} it is produced starting $6/15$.  In
Figure~\ref{fig:tg_agg3} vertices $v1$ and $v3$ create a single new
vertex $v1$ representing the institution.  A subsequent \insql{map}
operation to produce a new name attribute and a count of people would
produce a more meaningful final result.

\begin{figure*}[t]
%\centering
\begin{subfigure}[b]{0.5\textwidth}
\includegraphics[width=3.2in]{figs/agg1.pdf}
\caption{By time: $W=3~\textsf{months}, G_V=\textsf{vid}$.}
\label{fig:tg_agg1}
\end{subfigure}
\begin{subfigure}[b]{0.5\textwidth}
\includegraphics[width=3.2in]{figs/agg3.pdf}
\caption{Grouped by attribute: $W=1~\textsf{change}, G_V=\textsf{school}$.}
\label{fig:tg_agg3}
\end{subfigure}
\begin{subfigure}[b]{0.5\textwidth}
\includegraphics[width=3.2in]{figs/agg2.pdf}
\caption{By change: $W=3~\textsf{changes}, G_V=\textsf{vid}$.}
\label{fig:tg_agg2}
\end{subfigure}
\begin{subfigure}[b]{0.5\textwidth}
\includegraphics[width=3.2in]{figs/agg4.pdf}
\caption{By time with grouping: $W=3~\textsf{months}, G_V=\textsf{school}$.}
\label{fig:tg_agg4}
\end{subfigure}
\caption[]{Node creation, $Q_V=\insql{all}$, $Q_E=\insql{exists}$,
  $A_V=\insql{first}$, $A_E=\insql{first}.$}
\label{fig:tg_agg}
\vspace{-0.5cm}
\end{figure*}

\eat{Node creation may uncoalesce and requires FK enforcement.}

{\bf R1, R2}: coalesce every relation in $\ttt'$; {\bf R3}: enforce FK
on $\tav', \te', \tae'$; {\bf R4}: require reduce function.

\eat{ Our aggregation quantifiers are inspired by generalized
  quantifiers of~\cite{Hsu1995} with n-place delimiters.  $Q(R)$ as a
  Boolean-valued function of a relation''~\cite{Hsu1995}.  A
  quantifier contains an n-place determiner, e.g., ``at least one
  vertex in each window for each group'' is a 2-place determiner
  quantifier.  \tg algebra supports determiners from the set
  $\{at\ least\ one, all, most, at\ least\ n\}$, where $n$ is an
  integer representing a ratio.  $all$ is a usual universal quantifier
  that in standard SQL can be achieved with the use of two \insql{NOT
    EXISTS}.}

\subsection{Edge creation}
\label{sec:algebra:ecreate}

Edge creation operator outputs a new graph with edges based on the two
input \tgs.  Let $\ecr{\ttt_1}{q,red}{\ttt_2}$ be an edge creation
operator, where $q$ is a conjunctive query over constituent relations
of $\tve_1$ and $\tve_2$ and $red$ is a reduce function. $q$ must
return a valid temporal relation $(v_1, v_2, a_1, a_2)$.  The reduce
function is used to compute the final $\tae'$ relation.
$\ecr{\ttt_1}{q,red}{\ttt_2} = \{ \tv', \te', \tav', \tae' \}$, where
$\tae' = \sigma^T_{v_1,v_2,red(a_1,a_2)}(q(\ttt_1, \ttt_2))$ subject
to FK constraint from $\tv_1 \cup^T \tv_2$, $\te' =
\sigma^T_{v_1,v_2}(\tae')$, \tv' is a subset of $\tv_1 \cup^T \tv_2$
such that it contains only vertices with edges in $\te'$, and $\tav'$
is an empty relation.  Intuitively, edge creation returns a new \tg
from nodes of $\ttt_1$ and $\ttt_2$ with no attributes, connected by
edges determined by $q$.

Edge creation has several important applications.  In graph theory, a
graph join of two undirected unlabeled disjoint graphs is defined as
the union of the two graphs and additional edges connecting every
vertex in graph one with each vertex in graph two.  We can obtain a
graph join by the application of edge creation with $q = $ a temporal
cartesian product of $\tv_1$ and $\tv_2$.
SocialScope~\cite{Amer-Yahia2009} defines a nontemporal graph
composition operator which produces a graph induced by edges that are
composed from edges in the two operands connected by a common vertex
with a directional condition.  In \ql temporal graph composition can
be computed using node creation of \ttt with itself and a $q = $ a
temporal theta-join of $\tae$ and $\tae_2$.  This allows computation
of friend-of-friend edges, which, if applied k times, can answer k-hop
queries.  Since $q$ can include predicates over the timestamps, edge
creation can also compute journeys.  A journey is a path in the
evolving graph with non-decreasing time
edges~\cite{Ferreira2004,Casteigts2011}.  By adding a temporal
condition to the theta-join of $\tae_1$ and $\tae_2$ we can obtain
journeys similar to time-concurrent paths.

\julia{Example of edge transpose goes here.}

Note that edge creation is not additive, it produces {\em new} edges.
To add these edges to the original graph, a subsequent union must be
performed.

\eat{Graph composition operator in our algebra is a temporal extension of
the composition operator in SocialScope~\cite{Amer-Yahia2009}.  It
produces a graph induced by edges that are composed from edges in the
two operands for any time point when they coexisted.  The value of the
new edge attributes is determined by the resolve function, similar to
the set based operators.}

\eat{
Let $\odot_{\delta,r}$ be a composition operator, where $\delta$ is a
directional condition pair $d_1=v_1|v_2, d_2=v_1|v_2$ and $r$ is a
resolve function.  Then $\ttt_1 \odot_{\delta,r} \ttt_2 = \{ \tv',
\te', \tav', \tae' \}$, where $\forall (v_x,v_z,p) \in \te' \exists
(d_1,v_x,p_1) \in \te_1 \wedge (d_2,v_z,p_2) \in \te_2 \wedge p=p_1
\cap p_2$, \tv' contains only vertices with edges in \te', with FK
constraint enforced on \tav' from \tv', and $\forall (v_x,v_z,p,a) \in
\tae' \exists (d_1,v_x,p_1,a_1) \in \tae_1 \wedge (d_2,v_z,p_2) \in
\tae_2 \wedge p=p_1 \cap p_2 \wedge a=r((a_1,p_1),(a_2,p_2))$.
}

\eat{For example, to create edges between vertices that have two degrees of
separation, i.e. friends of friends, we can compose the graph with
itself with $d_1=v_2$ and $d_2=v_2$.  }

{\bf R1, R2}: coalesce $\te'$ and $\tae'$; {\bf R3}: constraint $\te'$
on $\tv'$, $\tv'$ on $\te'$ (to remove nodes with no edges), and
$\tae'$ on $\te'$; {\bf R4}: require reduce function.

\input{analytics}

%\input{example}
