\section{Algebra}
\label{sec:algebra}
\setlength{\textfloatsep}{5pt}% Remove \textfloatsep

\tg algebra is compositional: operators take a \tg or a pair of \tgs
as input, and output a \tg.  As is appropriate for a point-based
temporal data model (Section~\ref{sec:model}), our algebra has the
properties of snapshot reducibility and extended snapshot
reducibility~\cite{DBLP:reference/db/Bohlen092}.

In Section~\ref{sec:algebra:prelim} we state our design choices.
Then, in Sections~\ref{sec:algebra:integrity}
through~\ref{sec:algebra:composition} we present the algebraic
opearators.  We show formal properties of \tg algebra in
Section~\ref{sec:formal}.  All non-trivial proofs are listed in the
Appendix.

\subsection{Design choices}
\label{sec:algebra:prelim}

Our goal in developing \tg algebra is to give users an ability to
concisely express a wide range of common analysis tasks, while at the
same time preserving inter-operability with standard SQL.  For this
reason our data model is based on the temporal relational model, and
our algebra corresponds to temporal relational calculus, a two-sorted
logic with variables and quantifiers explicitly ranging over the time
domain~\cite{DBLP:reference/db/Toman09}, for graphs.  We will make
this relationship precise in Section~\ref{sec:formal}.

As a consequence, our data structure and algebraic operations can be
implemented on top of a relational engine.  Implementing
(non-temporal) graph querying and analytics in an RDBMS has been
receiving renewed
attention~\cite{DBLP:conf/sigmod/AbergerTOR16,DBLP:conf/sigmod/SunFSKHX15,DBLP:journals/pvldb/Xirogiannopoulos15},
and our work is in-line with this trend.

We do not support general recursion or transitive closure
computation in our algebra. (Although, as we will see in
Section~\ref{sec:analytics}, Pregel-style graph analytics such as
PageRank are supported as an extension.)  For this reason, we also do
not support regular path queries (RPQ) or the more general path query
classes (CRPQ and ECRPQ).  Extending our formalism with recursion and
path queries is non-trivial, and we leave this to future work, see
Section~\ref{sec:conc} for a discussion.

Rather than focusing on path computation and graph traversal, we
stress tasks that perform whole-graph analysis over time.  Several
such tasks were described in Section~\ref{sec:cases}.  Additional
examples can be found in SocialScope~\cite{Amer-Yahia2009} --- a
closed graph algebra motivated by information discovery in social
content sites.  All operations of SocialScope can be expressed in
\ql. \julia{Let's confirm this.}

\subsection{Resolve function}
\label{sec:algebra:integrity}

One of the requirements of our model is that each entity exists only
once during any time instant $t$.  To maintain soundness we introduce
a {\em resolve} function.

\begin{definition}[Resolve function]
Let $((a_l,p_l),(a_r,p_r))$ be a pair of possible values of a property
of a vertex or an edge, along with the associated validity periods.  A
{\em resolve function} produces a single property value with its
validity period $(a,p) = resolve((a_l,p_l), (a_r,p_r))$.
\end{definition}

A resolve function can pick an arbitrary element, compute an average,
put the values in a set, etc.  When applied over a bag of values in a
reduce fashion, a resolve function is an {\em aggregation function}.
We support the standard \{ \insql{count} | \insql{min} | \insql{max} |
\insql{sum} \}, which have their customary meaning.  We also support
\{ \insql{any} | \insql{first} | \insql{last} | \insql{set} |
\insql{bag} \}, which are possible to compute because properties being
resolved have temporal information.  \insql{first} and \insql{last}
refer to the value of an attribute with the earliest/latest timestamp,
while \insql{set} and \insql{bag} associate a key an unordered
collection of values with the set or bag semantics (but do not keep
the associated validity periods).  Finally, we support \{ \insql{left}
| \insql{right} \}, which select the attribute of the left,
resp. right, operand.  Other, more complex, functions can be defined
by the user.

In temporal relational algebra with point semantics soundness depends
on maintaining the coalesced state of the relation.  This requirement
holds in our algebra as well and we discuss it in detail in
Section~\ref{sec:sys:coal}.  However, because all four relations of
\tve are keyed temporal relation, we have an additional requirement in
our model.  Namely, that no entity, vertex or edge, may exist more than
once during any time point.  If, for example, a union of two \tav
relations is computed using regular temporal union semantics, it may
produce two tuples if the attribute values are not value-equivalent.
This clearly violates part~\ref{def:tg:c4} of Definition~\ref{def:tg}.

\begin{lemma}
Let $\psi$ be an n-ary temporal operator on \tg.  If $\psi^T (\ttt)$
produces multiple possible attribute values for any entity at the same
time instant, it must also specify a resolve function for each
property to compute a single valid attribute value.
\end{lemma}

The property graph model allows for arbitrary properties to be
associated with the graph entities, so it may be impractical or
infeasible to have the user specify a resolve function for each
possible property.  A default resolve function such as a \insql{set}
can be used for this purpose.

\eat{ This objective informed our design of
  the algebra, e.g., we did not include some flavors of temporal
  aggregation because the result would be invalid.  Further, this
  objective informs the rewriting of applicable operations over the
  \ve representation.}  

Each operator in our algebra produces a valid \tg.  We note which
operators are known to uncoalesce the output, thus requiring
coalescing, require FK enforcement, or include resolve functions.

\subsection{Unary operators}
\label{sec:algebra:unary}

We introduce three basic unary operators: slice, subgraph, and map.
%\subsection{Slice}
%\label{sec:algebra:slice}

{\bf Slice.}  The unary {\em slice} operator, denoted $\tau_{\bc} (\ttt)$,
where $\bc$ is a time period, cuts a temporal slice from \ttt.  The
resulting \tg will contain vertices and edges whose period $\bp$ has a
non-empty intersection with $\bc$.  To evaluate $\tau_{\bc} (\tve)$, we
apply $\tau_{\bc}$ to each of the four constituent relations of \tve:
$\tau_{\bc} (\tv) = \{ (v, \bp \cap \bc)~~|~~(v, \bp) \in \tv \wedge
(\pred{\bc}{overlaps}{\bp} \vee \pred{\bc}{contains}{\bp}) \}$, and
analogously for each \te, \tav and \tae.

\eat{If $p.start < c.start$ or $p.end > c.end$ for some tuple $(g,
  p)$, then $p$ is trimmed to be within the boundaries of $c$: $\tau_c
  (\trg) = \{ (g, p \cap c)~~|~~(g, p) \in \trg \wedge
  (\pred{c}{overlaps}{p} \vee \pred{c}{contains}{p})\}$.  }

Slice does not uncoalesce and does not require FK enforcement.  The
proofs for this and similar statements below are included in
Appendix~\ref{sec:app1}.

%\subsection{Temporal subgraph matching}
%\label{sec:algebra:subgraph}

{\bf Subgraph.}  Temporal subgraph matching is defined analogously to
subgraph matching in non-temporal graphs: it applies a predicate to
each vertex and edge of \tg.  We focus on functions that can be
expressed as a pair of {\em conjunctive queries} $\sigma_{C_V,C_E}
(\ttt)$, where $C_V$ specifies a predicate over the vertices and $C_E$
--- over the vertex-edge triplets.  The predicates can be over the
attributes, ids, and the timestamps of the vertices and edges.  We
allow predicates over the timestamps to support extended snapshot
reducibility.  Computing arbitrary subgraphs with path expressions is
beyond the scope of this paper, and we defer this to future work.

$\sigma_{C_V,C_E} (\ttt) = (\tv',\te',\tav',\tae') ~|~$ \\
$\tv' = \pi_{v,p} (\sigma_{C_V} ( \tv \bowtie^T_v \tav))$ \\
$\te' = \pi_{v_1,v_2,p} (\sigma_{C_E} ( \tae \bowtie^T_{v_1} \tav \bowtie^T_{v_2} \tav))$ \\
$\tav' = \sigma_{C_V} (\tav)$ \\
$\tae' = \pi_{v_1,v_2,a} (\sigma_{C_E} (\tae \bowtie^T_{v_1} \tav \bowtie^T_{v_2} \tav))$

Note that as B{\"{o}}hlen showed in~\cite{DBLP:reference/db/Bohlen09},
correctness of a select operator with a temporal predicate depends on
the coalesced state of the relation.  When composing a triplet, we
carry the vertex and edge timestamps in their entirety as data to
produce correct results.

Because we allow predicates over the triplets, interesting conditions
can be expressed.  For example, we can filter out any edges where the
value of some property of its two vertices does not match.  Assuming
vertices have property \insql{group}, we can compute
$\sigma_{T,v1.a.group=v2.a.group}(\ttt)$.

\eat{To ensure that a valid \tg is
  computed as a result of this operation, we restrict our attention to
  functions that compute a single subgraph of a given representative
  graph as a result: $\sigma_f (\trg) = \{ (g', p)~~|~~(g, p) \in \trg
  \wedge g' = f(g) \wedge$\\$V_{g'} \subseteq V_{g} \wedge E_{g'}
  \subseteq E_{g} \}$.}  
\eat{Even more specifically, we focus on functions
that can be expressed as a pair of {\em conjunctive queries}
$\sigma_{C_V,C_E} (\ttt)$, where $C_V$ specifies predicates over the
vertices, and $C_E$ --- over the edges.  The predicates can be over
the attributes and also over the timestamps of the vertices/edges, to
support the extended snapshot reducibility.  Computing arbitrary
subgraphs of an evolving graph is beyond the scope of this paper, and
we defer this to future work.
}
\eat{
$\sigma_{C_V,C_E} (\tve) = (\tv',\te',\tav',\tae') ~|~$ \\
$\tv' = \pi_{v,p} (\sigma_{C_{V1}} (\tv) \bowtie^T \sigma_{C_{V2}} (\tav)) \wedge \tav' = \sigma_{C_{V2}} (\tav)$ \\
$\te' = \pi_{v_1,v_2,p} (\sigma_{C_{E1}} (\te) \bowtie^T \sigma_{C_{E2}} (\tae)) \wedge \tae' = \sigma_{C_{E2}} (\tae)$.
}

\eat{Like other unary operators, $\sigma_{C_V, C_E} (\tve)$ follows the
outline of Algorithm~\ref{alg:op}.  Since $C_V$ and $C_E$ may involve
predicates over the attributes, we compute the join of the vertex
(resp. edge) relation with the corresponding attribute relation and
push selections:$\tv' = \pi_{v,p} (\sigma_{C_{V1}} (V) \bowtie
\sigma_{C_{V2}} (\tav))$ (line 1),$\te' = \pi_{v_1,v_2,p}
(\sigma_{C_{E1}} (E) \bowtie \sigma_{C_{E2}} (\tae))$ (line 2), $\tav'
= \sigma_{C_{V2}} (\tav)$ (line 3), $\tae' = \sigma_{C_{V2}} (\tae)$
(line 4).}

\eat{Subgraph does not uncoalesce, but does require FK enforcement for
  \tve.}  

Subgraph uncoalesces and requires FK enforcement. (Appendix~\ref{sec:app1})

%\subsection{Temporal map}
%\label{sec:algebra:project}

{\bf Map.}  The map operation applies user-defined map functions $M_V$
and $M_E$ to the vertices and edges of \tg.  To evaluate
$\map_{M_V,M_E} (\tve)$, we set $\tv'=\tv$ and $\te'=\te$, and compute
$\tav' = \map_{M_V}(\tav)$ and $\tae' = \map_{M_E}(\tae)$.

\eat{Temporal map iterates over the tuples of \trg, and applies the
user-specified map functions $M_V$ and $M_E$ to the vertices and edges
of each $g$: $\map_{M_V,M_E} (\trg) = \{(g', p)~~|~~(g,p) \in \trg
\wedge g'= \map_{M_V,M_E}(g)\}$.
}  

While map is an arbitrary user-specified function, there are some
common use cases.  Map can be used to remove vertex and edge
properties, as in projection.  In such cases we will use short-hand
notation similar to projection, listing the properties that we wish to
retain. For example, $\map_{M_V:{school},M_E:\emptyset} (\insql{T1})$
will keep only the school property of the vertices, and no properties
of the edges.  Another useful map operation eliminates duplicates in
the bag of a particular vertex or edge property.  \eat{It may also be
useful to flatten nested bags or aggregate multiple values of the same
property of a vertex or edge, e.g., compute a sum or an average
following temporal intersection or union
(Section~\ref{sec:algebra:join}).}

Map may uncoalesce \tav and \tae, but does not require FK enforcement.

\subsection{Binary operators}
\label{sec:algebra:binary}

We support the temporal versions of the three binary set operators
intersection ($\cap^T$), union ($\cup^T$), and difference
($\setminus^T$), as well as semi join.  As Dignos et al. showed, the
three set operators are not schema robust~\cite{Dignos2012}.  Schema
robust operators are not affected if the argument relation is extended
by an additional attribute.  This presents a problem when executing
the set operations over the \tav and \tae relations as there is no
guarantee that a vertex or an edge with the same identity and at the
same time instant has the same attribute set.  Thus all three
operators require resolve functions.

\begin{definition}[Set-theoretic operators]
Let $\oplus$ be a temporal set operator $\in \{ \cap^T, \cup^T,
\setminus^T \}$ and $r$ be a resolve function.  Then $\tve_1 \oplus_r
\tve_2 = \{ \tv_1 \oplus \tv_2, \te_1 \oplus \te_2, map_r(\tav_1
\fullouterjoin^T \tav_2),$\\ $map_r(\tae_1 \fullouterjoin^T \tae_2)
\}$, with all FK constraints on \tav and \tae enforced.
\label{def:sets}
\end{definition}

Because the graphs do not have a fixed schema, it may not be desirable
to specify a resolve function for every possible property.  A default
resolve function is \insql{set}.

%\subsection{Temporal graph intersection}
%\label{sec:algebra:join}
\eat{
The binary temporal graph intersection operation $\trga \cap \trgb$
computes a temporal join~\cite{Gao2005} of \trga and \trgb with the
predicate $\trga.p \cap \trgb.p \neq \emptyset$, producing a tuple for
each pair of representative graphs for which time periods intersect:
$\trga \cap \trgb = \{(g_1 \cap g_2, p_1 \cap p_2)~|~((g_1, p_1) \in
\trga \wedge (g_2, p_2) \in \trgb \wedge p_1 \cap p_2 \neq \emptyset
\}$.  The result of $g_1 \cap g_2$ is computed by intersecting the
sets of vertices and of edges of the graphs~\cite{GraphTheory}.  For
each vertex and edge in the result, we compute a {\em union} of their
bags of properties.% \julia{Figure with example.}
%
Algorithm~\ref{alg:inter} presents the evaluation of $\tvea \cap
\tveb$. We compute temporal joins over \tv and \te (lines 1, 2).  We
then compute \tav' and \tae' with temporal outer joins of the
corresponding relations (lines 3, 4).  Finally, we enforce foreign key
constraints on \te', \tav' and \tae' (lines 5, 6).
}

%\begin{algorithm}[b]
%\caption{Temporal graph intersection in \tve.}
%\begin{algorithmic}[1]
%%\REQUIRE $\tvea (\tv_1;\te_1;\tav_1;\tae_1), \tveb (\tv_2;\te_2;\tav_2;\tae_2)$.\\
%\REQUIRE $\tvea, \tveb$.\\
%\STATE $\tv' = \tv_1 \Join^T_v \tv_2$\\ 
%\STATE $\te' = \te_1 \Join^T_{v_1,v_2} \te_2$\\ 
%\STATE $\tav' = \cl (\pi_{v,p,\tav_1.a \cup \tav_2.a}\tav_1 \fullouterjoin^T_v \tav_2)$\\
%\STATE $\tae' = \cl (\pi_{v_1,v_2,p,\tae_1.a \cup \tae_2.a}\tae_1 \fullouterjoin^T_{v_1,v_2} \tae_2)$\\
%\STATE $\tae' = \pi_{a_1 \cap a_2}(\tae_1 \Join^T \tae_2)$\\
%\STATE enforce foreign keys on $\tav'$ w.r.t. $\tv'$\\ 
%\STATE enforce foreign keys on $\tae'$ w.r.t. $\te'$\\ 
%\RETURN new $\tve (\tv';\te';\tav';\tae')$\\
%\end{algorithmic}
%\label{alg:inter}
%\end{algorithm}

\begin{figure*}
%\centering
\begin{subfigure}{2.5in}
\includegraphics[width=2.5in]{figs/T2_rel.pdf}
\caption{T2.}
\label{fig:tg_t2}
\end{subfigure}
\begin{subfigure}{4.3in}
\includegraphics[width=4.3in]{figs/T1_union_T2_rel.pdf}
\caption{$T1 \cup^T T2.$}
\label{fig:tg_union}
\end{subfigure}
\begin{subfigure}{2.3in}
\includegraphics[width=2.3in]{figs/T1_inter_T2_rel.pdf}
\caption{$T1 \cap^T T2$.}
\vspace{-0.2cm}
\label{fig:tg_inter}
\end{subfigure}
\begin{subfigure}{2.3in}
\includegraphics[width=2.3in]{figs/T1_diff_T2_rel.pdf}
\caption{$T1 \setminus^T T2$.}
\vspace{-0.2cm}
\label{fig:tg_diff}
\end{subfigure}
\begin{subfigure}{2.3in}
\includegraphics[width=2.3in]{figs/T1_semij_T2_rel.pdf}
\caption{$T1 \ltimes^T T2$.}
\vspace{-0.2cm}
\label{fig:tg_semij}
\end{subfigure}
\caption{Binary operators.}
\label{fig:binary}
\vspace{-0.2cm}
\end{figure*}

Figure~\ref{fig:tg_inter} illustrates temporal intersection of \tg T2,
shown in Figure~\ref{fig:tg_t2}, with T1 in our running example, with
a set resolve function for all properties.  Period $[2/15, 4/15)$ for
  $v_2$ is computed as a result of the join of $[2/15, 5/15)$ in T1
    and [$2/15, 4/15)$ in T2.  Only the vertices and edges present in
      both \tgs are produced, thus eliminating $v_3$ and $v_4$.
      Notice the result of attribute set resolve function.
      Figure~\ref{fig:tg_union} is similar to
      Figure~\ref{fig:tg_inter} but using union instead of
      intersection.  According to the definition of temporal set
      union, periods are split to coincide for any group and thus the
      attribute values for e.g. $v_1$ now have three distinct tuples.
      Figure~\ref{fig:tg_diff} is a result of temporal difference of
      T1 and T2.  Vertex $v_1$ is now present before $2/15$ and after
      $6/15$, which splits the a single input tuple into multiple
      disjoin ones.

Intersection and union may uncoalesce, while difference does not.
Intersection and difference require FK enforcement for \tav and \tae,
while union does not.

%\subsection{Temporal graph union}
%\label{sec:algebra:outerjoin}

\eat{
The binary temporal graph union operation $\trga \cup \trgb$ computes
a temporal full outer join~\cite{Gao2005} of \trga and \trgb on the
predicate $\trga.p \cap \trgb.p $. For tuples $(g_1, p_1) \in \trga$
and $(g_2, p_2) \in \trgb$ for which $p_1 \cap p_2 \neq \emptyset$, we
compute $(g_1 \cup g_2, p_1 \cap p_2)$.  The result of $g_1 \cup g_2$
is computed by taking a {\em union} of the sets of vertices and of
edges of the graphs~\cite{GraphTheory}.  For each vertex and edge in
the result, we compute a {\em union} of their bags of properties.
Tuples from \trga (resp. \trgb) for which there does not exist a tuple
in \trgb (resp. \trga) for part or all of the validity period are
included in the result of the full outer join. 
}

\eat{
 $\trg_1 \cup \trg_2 = \{ (g, p) | (g_1, p_1) \in \trg_1 \wedge (g_2,
p_2) \in \trg_2 \wedge ((g = g_1 \cup g_2 \wedge p = p_1 \cap p_2
\wedge p_1 \cap p_2 \neq \emptyset) \vee (g = g_1 \wedge p = p_1 - p_2
\wedge \nexists p \in \trg_2 = p_1 - p_2) \vee (g = g_2 \wedge p = p_2
- p_1 \wedge \nexists p \in \trg_1 = p_2 - p_1))\}$.  Similar to
temporal intersection, temporal union is essentially an outer
theta-join of $\trg_1$ and $\trg_2$ with a $p_1 \cap p_2$ predicate.
We use the standard graph union definition based on set theory, which
computes unions of the vertex and edge sets from the two
operands~\cite{GraphTheory}.}

\eat{
Algorithm~\ref{alg:union} presents the evaluation of $\tvea \cup
\tveb$.  We compute temporal outer joins over the corresponding \tv,
\te, \tav and \tae.
}

\eat{\begin{algorithm}[t]
\caption{Temporal graph union in \tve.}
\begin{algorithmic}[1]
\REQUIRE $\tvea, \tveb$.\\
\STATE $\tv' = \tv_1 \fullouterjoin^T_v \tv_2$\\
\STATE $\te' = \te_1 \fullouterjoin^T_{v1,v2} \te_2$\\
\STATE $\tav' = \cl (\pi_{v,p,\tav_1.a \cup \tav_2.a}\tav_1 \fullouterjoin^T_v \tav_2)$\\
\STATE $\tae' = \cl (\pi_{v_1,v_2,p,\tae_1.a \cup \tae_2.a}\tae_1 \fullouterjoin^T_{v1,v2} \tae_2)$\\
\RETURN new $\tve (\tv';\te';\tav';\tae')$\\
\end{algorithmic}
\label{alg:union}
\end{algorithm}
}

%\subsection{Temporal graph difference}
%\label{sec:algebra:diff}

\eat{
The binary temporal graph difference operation $\trga \setminus \trgb$
computes a temporal left outer join~\cite{Gao2005} of \trga and \trgb
on the predicate $\trga.p \cap \trgb.p$.  For tuples $(g_1, p_1) \in
\trga$ and $(g_2, p_2) \in \trgb$ for which $p_1 \cap p2 \neq
\emptyset$, we compute $(g_1 \setminus g_2, p_1 \cap p_2)$.  The
result of $g_1 \setminus g_2$ is computed by taking a {\em set
  difference} of the sets of vertices and of edges of the graphs.  For
each vertex and edge in the result, we compute a {\em union} of their
bags of properties.  Tuples in \trga for which there does not exist a
tuple in \trgb for part or all of the validity period are included in
the result of the left outer join.
}
\eat{
Algorithm~\ref{alg:diff} presents the evaluation of $\tvea \setminus
\tveb$.  We compute temporal left outer joins over the corresponding
\tv and \te (lines 1,2).  We then compute $\tav'$ and $\tae'$ with
temporal outer joins of the corresponding relations (lines 3, 4).
Finally, we enforce foreign key constraints on $\te'$, $\tav'$, and
$\tae'$ (lines 5, 6).
}

\eat{\begin{algorithm}[b]
\caption{Temporal graph difference in \tve.}
\begin{algorithmic}[1]
\REQUIRE $\tvea, \tveb$.\\
\STATE $\tv' = \tv_1 \leftouterjoin^T_v \tv_2$\\ 
\STATE $\te' = \te_1 \leftouterjoin^T_{v_1,v_2} \te_2$\\ 
\STATE $\tav' = \cl (\pi_{v,p,\tav_1.a \cup \tav_2.a}\tav_1 \fullouterjoin^T_v \tav_2)$\\
\STATE $\tae' = \cl (\pi_{v_1,v_2,p,\tae_1.a \cup \tae_2.a}\tae_1 \fullouterjoin^T_{v_1,v_2} \tae_2)$\\
\STATE enforce foreign keys on $\tav'$ w.r.t. $\tv'$\\ 
\STATE enforce foreign keys on $\tae'$ w.r.t. $\te'$\\ 
\RETURN new $\tve (\tv';\te';\tav';\tae')$\\
\end{algorithmic}
\label{alg:diff}
\end{algorithm}
}

{\bf Semi join.}  The semi join operator $\ttt_1 \ltimes^T \ttt_2$
produces a subgraph induced by edges shared between \insql{T1} and
\insql{T2} at any time point.  The induced subgraph is based on
topology, i.e. $\tv' = \pi_{v,p} ( \te_1 \ltimes^T \te_2), \te' =
\te_1 \ltimes^T \te_2$ and the foreign key is enforced on \tav and
\tae.  A semi join of a \ttt with itself produces a graph with all
vertices having degree of at least 1.

Figure~\ref{fig:tg_semij} demonstrates the result of a semi join of
our running example \insql{T1} with \insql{T2}.  Only one period
$[2/15, 4/15)$ for all entities is retained because only a single edge
  during this period is shared between T1 and T2.

For a more complex example, to produce a subgraph of a particular
vertex $v_i$ and the immediate neighborhood of that vertex, we compute
$\ttt \ltimes (\sigma_{T,v_1=v_i | v_2=v_i} (\ttt))$.

Semi join does not uncoalesce but requires FK enforcement on \tav and
\tae.

\subsection{Aggregation}
\label{sec:algebra:agg}

Aggregation is a common graph operation that can be used to compute
simple properties such as in-degrees of vertices or more complex ones
such as a set of places that all close friends have visited in the
past year.  Aggregation is denoted $\gamma_{C_V,C_E,d,M,A_V}$, where
$C_V$ is a predicate over the source and destination vertices of the
edge, $C_E$ is a predicate over the edge itself, $d$ is the target
vertex $\in \{src,dst\}$, $M$ is the value (message) per edge, and $A_V$
is an aggregation function.  The result is a new graph
$\gamma_{C_V,C_E,d,M,A_V} (\ttt) = \ttt \cup^T \{ \tv, \te, \tav',
\tae \}$, where $\tav' = A_{V,d}(\sigma_{C_V,C_E} (\tae
\bowtie^T_{vid1=vid} \tav \bowtie^T_{vid2=vid} \tav))$.  The $C_V$ and
$C_E$ predicates may include temporal clauses.  We show in
Section~\ref{sec:sys:impl} how this is supported through an expansion
operation if implemented directly over the \tve representation.  The
temporal union is used to add the new attribute to the output since it
may have different periods of validity.  For example, while each vertex
in \tg may remain unchanged for the whole duration, aggregating vertex
degrees would result in an attribute value for each period of topology
change.

As an example, to compute vertex in-degrees, we can use
$\gamma_{true,true,dst,1,count}(\ttt)$.  To compute a set of places
that all close friends have visited in the past year, assuming there
is a property \insql{places} on friend vertices and closeness of
friendship property on edges, we can use $\gamma_{p \cap
  [2015,2016),close > 0.8,dst,places,set}(\ttt)$.

Aggregation does not uncoalesce and does not require FK enforcement.

\subsection{Node creation}
\label{sec:algebra:create}

We argued in the introduction that it is interesting and insightful to
analyze an evolving graph at different levels of granularity.  For
example, the user may want to aggregate multiple consecutive
representative graphs into a single representative graph, coarsening
the granularity, or to predefine temporal resolution and look at the
graph at that scale, irrespective of whether this resolution happens
to be finer or coarse than the natural evolution rate of the graph.
For this, we introduce a node creation operator which is similar to
the {\em moving window temporal aggregation} in temporal relational
algebra.  Our approach is inspired by stream aggregation work
of~\cite{Li2005}, adopted to graphs, and by generalized quantifiers
of~\cite{Hsu1995}.

Node creation is denoted $_{G_V}\vartheta_{W,Q_V,Q_E,A_V,A_E}
(\ttt)$,\\ where $G_V$ are the grouping attributes, $W$ is the window
specification, $Q_V$ and $Q_E$ are vertex and edge quantifiers, and
$A_V$ and $A_E$ are the optional aggregation functions.  It produces a
consolidated evolving graph with specific temporal granularity.

{\em Grouping attributes} $G_V$ are vertex properties by which
vertices are grouped into new entities, similar to \insql{GROUP BY}
clause in SQL.  Since node creation requires new identifiers, the
combination of the grouping properties can be used in a mechanism
equivalent to a Skolem function.  The simplest, default grouping
attribute is the $vid$ of the vertex.

{\em Window specification} $W$ is of the form
$n~\{unit|\insql{changes}\}$, where $n$ is an integer, and $unit$ is a
time unit, e.g., $10~min$, $3~years$, or any multiple of the usual
time units.  Window specification of the form $n~\insql{changes}$
defines the window in terms of change over \trg.\eat{ (which may be
  computed from the \tve representation, see
  Section~\ref{sec:model:switch}).}  For example,
$W=3~\insql{changes}$ will aggregate sequences of 3 representative
graphs into 1.  Window boundaries are computed left-to-right, i.e.,
from least to most recent.  The right-most window may correspond to
fewer than $n$ representative graphs from the input.
%
Our window specification by change is similar to slide-by-row window
in stream aggregation~\cite{Li2005}.  Note that, because \tg algebra
is compositional, we do not support node creation with
overlapping windows, because it does not produce a valid \tg.  To see
why this is so, consider applying a sliding window of 3 months range
with 1 month slide to graph \insql{T} in Figure~\ref{fig:tg_rg}.  We
would produce the following set $(g_1, [1/15, 4/15)), (g_2, [4/15,
    7/15)), (g_3, [7/15, 10/15))$, which clearly violates the
      temporally coalesced requirement in
      definition~\ref{tg_abstract}.  

Similar to~\cite{Li2005} we support creation simultaneously by time
and by non-temporal attributes (e.g., vertex properties).  If the
window specification is one change, then the operation devolves into
pure structural reduce or node creation, as classified by
Wood~\cite{Wood2012}.  If the grouping attribute is the vertex $vid$,
then the operation is purely temporal, with no structural aspect.

{\em Quantifiers} $Q_V$ and $Q_E$ are of the form \{ \insql{all} |
\insql{most} | \insql{at least} $n$ | \insql{exists} \}, where $n$ is
a decimal representing the percentage of the time during which an
entity (vertex or edge) existed, relative to the duration of the
window. These are useful for producing different kinds of
representative graphs.  For example, to produce representative graphs
with only strong connections over a volatile evolving graph, we may
want to only include vertices that span the entire time window
($Q_V=\insql{all}$), and edges that span a large portion of the window
($Q_E=\insql{most}$).
 
The optional {\em aggregation functions} $A_V$ and $A_E$ compute new
values for vertex and edge properties representative of
the whole window, e.g., $A_V=\insql{any}(name), \insql{last}(school)$
and $A_E=\insql{sum}(cnt)$.
%
 
Key-value pairs for vertex and edge properties for which no
aggregation functions are specified, are collected into a bag
corresponding to the entity in the result.  These can be subsequently
transformed with $map^T$ (Section~\ref{sec:algebra:project}).

\eat{ 
Temporal aggregation over \tve follows the outline of
Algorithm~\ref{alg:op}, but requires an additional step, and is
revisited in Algorithm~\ref{alg:agg_ve}.
%
}

We compute group periods based on window specification.  Next, as part
of $_{G_V}\vartheta_{P,Q_V}(\tv)$ computation, we assign each tuple from
\tv to a period (this requires splitting), group vertices by $G_V$ and
evaluate $Q_V$ on each group.  Only groups for which $Q_V$ evaluates
to true are retained.  Edges are processed similarly by
$_{G_V}\vartheta_{P,Q_E}(\te)$.  Note that when $G_V$ is anything besides
$vid$, we need edge triplets in order to compute new source and
destination ids of each edge.  As with aggregation above, edge
triplets can be computed through a three-way temporal outerjoin of
\tae with \tav.  $_{G_V}\vartheta_{P,A_V}(\tav)$ and
$_{G_V}\vartheta_{P,A_E}(\tae)$, respectively, are a result of computing
a group for each vertex or edge within the period, and applying the
aggregate functions over each group.

\eat{
Node creation over \trg is computed by first calculating time periods
from $W$ and \trg, and then reducing and combining the representative
graphs directly.
}

\eat{\begin{algorithm}[t!]
\caption{Node creation in \tve.}
\begin{algorithmic}[1]
\REQUIRE \tve (\tv;\te;\tav;\tae), window specification $W$, vertex
quantifier $Q_V$, edge quantifier $Q_E$, vertex aggregate function
$A_V$, vertex aggregate function $A_E$.\\
\STATE $P = \textsf{computePeriods}(W, \tv, \te, \tav, \tae)$\\
\STATE  $\tv' = \cl (_{G_V}\vartheta_{P,Q_V}(\tv))$\\
\STATE  $\te' = \cl (_{G_V}\vartheta_{P,Q_E}(\te))$\\
\STATE  $\tav' = \cl (_{G_V}\vartheta_{P,A_V}(\tav))$\\
\STATE  $\tae' = \cl (_{G_V}\vartheta_{P,A_E}(\tae))$\\
\STATE  follow steps 5-7 of Algorithm~\ref{alg:op}\\
%\STATE  enforce foreign keys on $\te'$ w.r.t. $\tv'$\\
%\STATE  enforce foreign keys on $\tav'$ w.r.t. $\tv'$\\
%\STATE  enforce foreign keys on $\tae'$ w.r.t. $\te'$\\
\RETURN new $\tve (\tv';\te';\tav';\tae')$\\
\end{algorithmic}
\label{alg:agg_ve}
\end{algorithm}
}

Figure~\ref{fig:tg_agg1} illustrates node creation by time
($W=3~\textsf{months}$), and Figure~\ref{fig:tg_agg2} --- by change
($W=3~\textsf{changes}$).  Figure~\ref{fig:tg_agg3} illustrates
structural reduce only ($W=1~\textsf{change}$), and
Figure~\ref{fig:tg_agg4} both structural and temporal
($G_V=\textsf{school}, W=3~\textsf{months}$).  All four are applied to
\insql{T1} in our running example, and list the same quantifiers
(\insql{all} for vertices and \insql{exists} for edges) and aggregate
functions (\insql{first} for vertex and edge properties).  $v_2$ is
present in the result in Figure~\ref{fig:tg_agg1} starting at $4/15$
because it did not exist for the entirety of the first window, while
in Figure~\ref{fig:tg_agg2} it is produced starting $6/15$.  In
Figure~\ref{fig:tg_agg3} vertices $v1$ and $v3$ create a single new
vertex $v1$ representing the institution.  A subsequent \insql{map}
operation to produce a new name attribute and a count of people would
produce a more meaningful final result.

\begin{figure*}[t]
%\centering
\begin{subfigure}[b]{0.5\textwidth}
\includegraphics[width=3.2in]{figs/agg1.pdf}
\caption{By time: $W=3~\textsf{months}, G_V=\textsf{vid}$.}
\label{fig:tg_agg1}
\end{subfigure}
\begin{subfigure}[b]{0.5\textwidth}
\includegraphics[width=3.2in]{figs/agg3.pdf}
\caption{Grouped by attribute: $W=1~\textsf{change}, G_V=\textsf{school}$.}
\label{fig:tg_agg3}
\end{subfigure}
\begin{subfigure}[b]{0.5\textwidth}
\includegraphics[width=3.2in]{figs/agg2.pdf}
\caption{By change: $W=3~\textsf{changes}, G_V=\textsf{vid}$.}
\label{fig:tg_agg2}
\end{subfigure}
\begin{subfigure}[b]{0.5\textwidth}
\includegraphics[width=3.2in]{figs/agg4.pdf}
\caption{By time with grouping: $W=3~\textsf{months}, G_V=\textsf{school}$.}
\label{fig:tg_agg4}
\end{subfigure}
\caption[]{Node creation, $Q_V=\insql{all}$, $Q_E=\insql{exists}$,
  $A_V=\insql{first}$, $A_E=\insql{first}.$}
\label{fig:tg_agg}
\vspace{-0.5cm}
\end{figure*}

Node creation may uncoalesce and requires FK enforcement.

\eat{ Our aggregation quantifiers are inspired by generalized
  quantifiers of~\cite{Hsu1995} with n-place delimiters.  $Q(R)$ as a
  Boolean-valued function of a relation''~\cite{Hsu1995}.  A
  quantifier contains an n-place determiner, e.g., ``at least one
  vertex in each window for each group'' is a 2-place determiner
  quantifier.  \tg algebra supports determiners from the set
  $\{at\ least\ one, all, most, at\ least\ n\}$, where $n$ is an
  integer representing a ratio.  $all$ is a usual universal quantifier
  that in standard SQL can be achieved with the use of two \insql{NOT
    EXISTS}.}

\subsection{Composition}
\label{sec:algebra:composition}

\eat{In graph theory, a graph join of two undirected unlabeled disjoint
graphs is defined as the union of the two graphs and additional edges
connecting every vertex in graph one with each vertex in graph two.}

Graph composition operator in our algebra is a temporal extension of
the composition operator in SocialScope~\cite{Amer-Yahia2009}.  It
produces a graph induced by edges that are composed from edges in the
two operands for any time point when they coexisted.  The value of the
new edge attributes is determined by the resolve function, similar to
the set based operators.

\begin{definition}[Composition]
Let $\odot_{\delta,r}$ be a composition operator, where $\delta$ is a
directional condition pair $d_1=v_1|v_2, d_2=v_1|v_2$ and $r$ is a
resolve function.  Then $\ttt_1 \odot_{\delta,r} \ttt_2 = \{ \tv',
\te', \tav', \tae' \}$, where $\forall (v_x,v_z,p) \in \te' \exists
(d_1,v_x,p_1) \in \te_1 \wedge (d_2,v_z,p_2) \in \te_2 \wedge p=p_1
\cap p_2$, \tv' contains only vertices with edges in \te', with FK
constraint enforced on \tav' from \tv', and $\forall (v_x,v_z,p,a) \in
\tae' \exists (d_1,v_x,p_1,a_1) \in \tae_1 \wedge (d_2,v_z,p_2) \in
\tae_2 \wedge p=p_1 \cap p_2 \wedge a=r((a_1,p_1),(a_2,p_2))$.
\label{def:composition}
\end{definition}

For example, to create edges between vertices that have two degrees of
separation, i.e. friends of friends, we can compose the graph with
itself with $d_1=v_2$ and $d_2=v_2$.  Note that composition is not
additive, it produces {\em new} edges.  To add these edges to the
original graph, a subsequent union must be performed.  

Composition does not uncoalesce \tv, \te, or \tav, but may uncoalesce
\tae.  FK enforcement is required on \tav.

\eat{
$\forall (v_x,v_z,p) \in \te' (\exists (v_x,v_y,p_1) \in \te_1 \wedge (v_y,v_z,p_2) \in \te_2 \wedge p = p_1 \cap p_2 \wedge d1=v2 \wedge d2=v1) \vee (\exists (v_y,v_x,p_1) \in \te_1 \wedge (v_y,v_z,p_2) \in \te_2 \wedge p = p_1 \cap p_2 \wedge d1=v1 \wedge d2=v1) \vee (\exists (v_x,v_y,p_1) \in \te_1 \wedge (v_z,v_y,p_2) \in \te_2 \wedge p = p_1 \cap p_2 \wedge d1=v2 \wedge d2=v2) \vee (exists (v_y,v_x,p_1) \in \te_1 \wedge (v_z,v_y,p_2) \in \te_2 \wedge p = p_1 \cap p_2 \wedge d1=v1 \wedge d2=v2)$
}

\input{analytics}

\input{example}
