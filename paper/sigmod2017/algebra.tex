\section{Algebra}
\label{sec:algebra}
\setlength{\textfloatsep}{5pt}% Remove \textfloatsep

\tg algebra, or \tga for short, is compositional: operators take a \tg
or a pair of \tgs as input, and output a \tg.  We specify the
semantics of \tga by showing a translation of each operator into a
sequence of temporal relational algebra (\tra) expressions (with
nesting, to accommodate non-1NF vertex/edge attributes).  Using this
translation one can implement \tga in a temporal DBMS, guaranteeing
snapshot reducibility and extended snapshot
reducibility~\cite{DBLP:reference/db/Bohlen092} --- two properties
that are appropriate for a point-based temporal data model.

\julia{TRA refresher: time as data, RA operations implicitly handle
  time (snapshot reducibility), explicit reference to time are
  supported in the predicates (extended snapshot reducibility), but
  time cannot be ``created''.}

%\julia{Explain temporal subset}

In Section~\ref{sec:algebra:integrity} we present the primitives that
are needed to enforce soundness of \tga.  Then, in
Sections~\ref{sec:algebra:unary} through~\ref{sec:algebra:ecreate}, we
present \tga operators.  Section~\ref{sec:analytics} presents an
extension of \tga to support Pregel-style analytics.  We conclude by
showing expressiveness of \tga in Section~\ref{sec:algebra:formal}.

\subsection{Soundness}
\label{sec:algebra:integrity}

\tga operators are translated into a sequence of expressions in
temporal relational algebra (\tra).  Since TRA is applied to
individual relations of \tve, we must ensure that the combined state
of these relations in the result corresponds to a valid \tg, i.e.,
that the translation is sound.  Recall from Definition~\ref{def:tg}
that a valid \tg must satisfy four requirements: {\bf R1}: Unique
vertices and edges, {\bf R2}: Unique attribute values, {\bf R3}:
Referential integrity, and {\bf R4}: Coalesced.  We now describe three
primitives that will ensure soundness of \tga.

{\bf Coalesce.} To enforce requirements {\bf R1} and {\bf R4}, we
introduce the coalesce primitive $\coal{R}$, which merges adjacent or
overlapping time periods for value-equivalent tuples.  This operation
is similar to duplicate elimination in conventional databases, and has
been extensively studied in the
literature~\cite{DBLP:conf/vldb/BohlenSS96,DBLP:journals/sigmod/Zimanyi06}.
$\coal{R}$ is applied to individual relations of \tve, or to
intermediate results, following the application of operations that
uncoalesce.  That the coalesce primitive can be implemented in
relational algebra~\cite{DBLP:conf/vldb/BohlenSS96}.  Note that eager
coalescing is not always desirable, since it is expensive and some
operations may produce correct results (up to coalescing) even when
computing over uncoalesced inputs~\cite{DBLP:reference/db/Bohlen09}.
Finally, if a DBMS supports automatic coalescing, this primitive is
not necessary.

{\bf Resolve.} To enforce {\bf R2} we introduce the resolve primitive
$\resolve{f_1(k_1), \ldots, f_n(k_n)}{R}$, which is invoked by
operations that produce attribute relations with duplicates.  Resolve
computes a temporal group-by of the attribute relation $R$ by key
(e.g., by $v$ if $R$ represents vertex attributes).  It then computes
a bag-union of the properties occurring in each group, groups together
key-value pairs that correspond to the same property name $k_i$, and
aggregates values within each group using the specified aggregation
function $f_i$.  If no aggregation function is specified for a
particular property name, \insql{set} is used as the default.  For
example, \julia{example: text or small figure}.

{\bf Constrain.} To enforce {\bf R3} we introduce the constrain
primitive $\constr{r}{s}$, which enforces referential integrity on
relation $\mathbf{r}$ with respect to relation $\mathbf{s}$.  For
example, this primitive is used to remove edges from \te for which one
or both vertices are absent from \tv, or validity period of an edge to
be within the validity periods of its vertices.

\eat{The reduce function may, for example, pick the left, the right,
  or an arbitrary element, compute the value of an aggregate function
  such as $\mathbf{COUNT}$, or accumulate values into a set.  A reduce
  function can be repeatedly applied to an unordered collection of
  values to compute a single value, as is done in the map-reduce
  model.  The property graph model allows for arbitrary properties to
  be associated with the graph entities, so it may be impractical or
  infeasible to have the user specify a reduce function for each
  possible property.  In \ql a default reduce function \insql{set} is
  used for any property without an explicitly stated reduction.}

\eat{\begin{lemma}
Let $\psi$ be an n-ary temporal operator on \tg.  If $\psi^T (\ttt)$
produces multiple possible attribute values for any entity at the same
time instant, it must also specify a resolve function for each
property to compute a single valid attribute value.
\end{lemma}}

\eat{In operator definitions below we note which operators are known to
uncoalesce the output, thus requiring coalescing, require FK
enforcement, or include reduce functions.  All non-trivial proofs are
listed in Appendix~\ref{sec:app1}.}

\subsection{Unary operators}
\label{sec:algebra:unary}

\paragraph*{Slice}  The slice operator, denoted $\slice{\bc}{\ttt}$, where
$\bc$ is a time interval, cuts a temporal slice from \ttt. The
resulting \tg will contain vertices and edges whose period $\bp$ has a
non-empty intersection with $\bc$.  We translate this \tga operator to
TRA statements over each constituent relation of \tve:
$\slice{\bc}{\tv}$ and similarly for \te, \tav and \tae.

%: $\slice{\bc}{\tv} = \{ (v, \bp \cap \bc)~~|~~(v, \bp) \in \tv
%\wedge (\pred{\bc}{overlaps}{\bp} \vee \pred{\bc}{contains}{\bp})
%\}$, and analogously for each \te, \tav and \tae.  apply select
%operator to each of the four constituent relations of \tve: $\forall
%x \in \{\tv,\te,\tav,\tae \}, x' = \pi_{A,p \cap c}(\sigma_{p \cap c}
%(x))$, where $A$ is the non-temporal schema of $x$.

\eat{If $p.start < c.start$ or $p.end > c.end$ for some tuple $(g,
  p)$, then $p$ is trimmed to be within the boundaries of $c$: $\tau_c
  (\trg) = \{ (g, p \cap c)~~|~~(g, p) \in \trg \wedge
  (\pred{c}{overlaps}{p} \vee \pred{c}{contains}{p})\}$.  }

Slice does not violate any of the soundness requirements {\bf R1} ---
{\bf R4}, see Appendix~\ref{sec:app1} for proofs of this and similar
statements.

\paragraph*{Subgraph}  Temporal subgraph matching is a generalization of
subgraph matching for non-temporal graphs~\cite{Wood2012}.  This query
comes in two variants.

\eat{A temporal vertex-subgraph query $q^T_v(\tve)$ is a conjunctive query
that takes $\tve (\tv, \te, \tav, \tae)$ as input, and outputs
$\tve'$, an induced temporal subgraph of \tve in which vertices are
defined by $q^T_v$.}

Temporal vertex-subgraph \subv{q^t_v}{\ttt} computes $\tve'(\tv',
\te', \tav', \tae')$, an induced subgraph of \tve with vertices
defined by the temporal conjunctive query (TCQ) $q^t_v$.  Note that
this is a subgraph query, and so $\tv' \subseteq^T \tv$.

\eat{A temporal edge-sugraph query $q^t_e(\tve)$ is a conjunctive query
that takes a graph $\tve (\tv, \te, \tav, \tae)$ as input, and outputs
a \tg $\tve'$ on the vertices of $\tve$ such that the edges of $\tve'$
are defined by $q^t_e$. }

Temporal edge-subgraph \sube{q^t_e}{\ttt} computes $\tve'(\tv', \te',
\tav', \tae')$, a subgraph of \ttt, where edges are defined by TCQ
$q^t_e$.  Since this is a subgraph query, $\te' \subseteq^T \te$.

Queries $q^t_v$ and $q^t_e$ may use any of the constituent relations
of \tve to compute the vertex/edge sets.  Further, since these
are TRA queries, they may explicitly reference temporal information,
and so require all input relations to be
coalesced~\cite{DBLP:reference/db/Bohlen09}.

Following the computation of $\tv' = q^t_v(\tv)$, \subv{q^t_v}{\ttt}
must invoke $\coal{\tv'}$ to enforce {\bf R1} and {\bf R4}; and
$\constr{\te'}{\tv'}$, $\constr{\tav'}{\tv'}$, $\constr{\tae'}{\te'}$
to enforce {\bf R3}.
%
Following the computation $\te' = q^t_e(\te)$, \subv{q^t_e}{\ttt} must
invoke $\coal{\te'}$ to enforce {\bf R1} and {\bf R4}; and
$\constr{\tae'}{\te'}$ to enforce {\bf R3}.  %No further
%validation is required, provided that $q^t_e$ outputs a temporal
%subset of \te.% (see Appendix~\ref{sec:app1}).

\eat{We focus on functions that can be expressed as a pair of {\em
  conjunctive queries} $\sigma_{C_V,C_E} (\ttt)$, where $C_V$
specifies a predicate over the vertices and $C_E$ --- over the
vertex-edge triplets.  The predicates can be over the attributes, ids,
and the timestamps of the vertices and edges.  We allow predicates
over the timestamps to support extended snapshot reducibility.
Computing arbitrary subgraphs with path expressions is beyond the
scope of this paper, and we defer this to future work.}

\eat{
$\sigma_{C_V,C_E} (\ttt) = (\tv',\te',\tav',\tae') ~|~$ \\
$\tv' = \pi_{v,p} (\sigma_{C_V} ( \tv \bowtie^T_v \tav))$ \\
$\te' = \pi_{v_1,v_2,p} (\sigma_{C_E} ( \tae \bowtie^T_{v_1} \tav \bowtie^T_{v_2} \tav))$ \\
$\tav' = \sigma_{C_V} (\tav)$ \\
$\tae' = \pi_{v_1,v_2,a} (\sigma_{C_E} (\tae \bowtie^T_{v_1} \tav \bowtie^T_{v_2} \tav))$}

\eat{ Note that as B{\"{o}}hlen showed
  in~\cite{DBLP:reference/db/Bohlen09}, correctness of a select
  operator with a temporal predicate depends on the coalesced state of
  the relation.  When composing a triplet, we carry the vertex and
  edge timestamps in their entirety as data to produce correct
  results.}

% There is no need for an example here, it is clear what these queries
% compute.

\eat{Because we allow predicates over the triplets, interesting conditions
can be expressed.  For example, we can filter out any edges where the
value of some property of its two vertices does not match.  Assuming
vertices have property \insql{group}, we can compute
$\sigma_{T,v1.a.group=v2.a.group}(\ttt)$.}

\eat{
Vertex-subgraph: {\bf R1,R2}: coalesce $\tv'$; {\bf R3}: enforce FK on
$\tav', \te', \tae'$. Edge-subgraph: {\bf R1,R2}: coalesce $\te'$;
{\bf R3}: enforce FK on $\te'$ and $\tae'$.}

\eat{Vertex-subgraph requires coalescing of $\tv'$ and FK enforcement on
\tav', \te', and \tae'. Edge-subgraph requires coalescing of $\te'$ and
FK enforcement on \tae'.}

%\subsection{Temporal map}
%\label{sec:algebra:project}

\paragraph*{Map}  Temporal vertex-map and edge-map apply
user-defined map functions $f_v$ and $f_e$ to vertex or edge
attributes.  Temporal vertex-map $\vmap{f_v, \tve}$ outputs $\tve'$ in
which $\tv'=\tv$, $\te'=\te$, $\tae' = \tae$, and $\tav' =
\pi_{v,f_v(a)}\tav$. Temporal edge-map $\emap{f_e, \tve}$ is defined
analogously.

\eat{To evaluate $\map_{M_V,M_E} (\tve)$, we set $\tv'=\tv$ and $\te'=\te$,
and compute $\tav' = \map_{M_V}(\tav)$ and $\tae' = \map_{M_E}(\tae)$.}

\eat{Temporal map iterates over the tuples of \trg, and applies the
user-specified map functions $M_V$ and $M_E$ to the vertices and edges
of each $g$: $\map_{M_V,M_E} (\trg) = \{(g', p)~~|~~(g,p) \in \trg
\wedge g'= \map_{M_V,M_E}(g)\}$.
}  

While $f_v$ and $f_e$ are arbitrary user-specified functions, there
are some common cases.  Map may specify the set of properties to
project out or retain, it may aggregate (e.g., \insql{COUNT}) or
deduplicate values of a collection property, or flatten a nested
value.

To produce a valid \tg, $\vmap{f_v, \tve}$ must invoke $\coal{\tv'}$
and $\emap{f_e, \tve}$ must invoke $\coal{\te'}$, enforcing {\bf R4}.

% because this is an arbitrary operation, we don't need to invent
% syntax here.  it's also clear what this operation does, I don't
% think there is a need for an example.

\eat{In such cases we will use short-hand
notation similar to projection, listing the properties that we wish to
retain. For example, $\map_{M_V:{school},M_E:\emptyset} (\insql{T1})$
will keep only the school property of the vertices, and no properties
of the edges.  Another useful map operation eliminates duplicates in
the bag of a particular vertex or edge property.  \eat{It may also be
useful to flatten nested bags or aggregate multiple values of the same
property of a vertex or edge, e.g., compute a sum or an average
following temporal intersection or union
(Section~\ref{sec:algebra:join}).}}

%Vertex-map: {\bf R2}: coalesce $\tav'$.  Edge-map: {\bf R2}: coalesce
%$\tae'$.

\eat{Vertex-map requires only coalescing of $\tav'$. Edge-map requires
  only coalescing of $\tae'$.}

\subsection{Aggregation}
\label{sec:algebra:agg}

Aggregation is a common graph operation that computes the value of a
vertex property $pname$ based on information available at the vertex
itself, at the edges associated with the vertex, and at its immediate
neighbors.  Aggregation can be used to compute simple properties such
as in-degree of a vertex, or more complex ones such as the set of
countries in which the friends of $v$ live.

It is convenient to think of aggregation as operating over a temporal
view $L(v_1,v_2,v_1.a,v_2.a,e.a,p)$, where $v_1$ refers to the vertex
for which the new property is being computed, $v_2$ refers to the
vertex from which information is gathered, $v_1.a$, $v_2.a$ and $e.a$
are attributes of the vertices and of the edge, and $p$ is the
associated time period.  $L$ is computed with a temporal join of \te
with two copies of \tv, one for each side of the edge, and with $\tav$
and $\tae$ outer-joined with the corresponding relations.  Outer-joins
are needed because a vertex / edge is not required to specify an
attribute.

When \tve represents a directed graph, and direction of the edge is
important for aggregation, it can be accounted for in the way the join
is set up (e.g., mapping $v_2$ in \te to $v_1$ in $L$ if the goal is
to aggregate information on incoming edges).  When \tve represents an
undirected graph (recall that we choose a canonical representation of
an edge, with $v_1 \leq v_2$), or when direction of the edge is
unimportant, $L$ can be computed from $\te(v_1,v_2,p) \cup^T
\te(v_2,v_1,p)$ rather than from $\te$.

Aggregation is denoted $\insql{agg}^T(dir,cond,f_m,f_a,pname,\ttt)$,
where $dir$ is the direction of the edge (one of 'right', 'left' or
'both') that determines how $L$ is computed, $cond$ is a predicate
over $L$, $f_m$ is a map function that emits a value for each tuple in
the result of $\sigma^T_{cond}(L)$ (e.g., 1 for computing degree of
$v_1$, or $v_2.a.country$ for computing the set of countries in which
the friends of $v_1$ live).  Finally, $f_a$ is the function that
aggregates values computed by $f_m$, and $pname$ is the name of the
property to which the computed value is assigned.  Putting everything
together, and omitting the computation of $L$ for clarity: we compute
a temporal relation $R = \coal{v_1 \gamma^T_{f_a} (\pi_{v_1,f_m}
(\sigma^T_{cond} L))}$.  We then compute an outer join of \tav with
$R$, and invoke the resolve primitive to reconcile the newly-computed
property stored in $R.a$ with $\tav.a$: $\tav' =
\resolve{\insql{set}(pname)}{\tav \rightouterjoin^T_{v=v_1} R}$.

\eat{The result is a new isomorphic graph $\ttt'$:
$\agg{cond,msg,red}{\ttt} = \{ \tv, \te, \tav', \tae \}$, where $\tav'
= \pi^T_{v,a_1+a_2}(\tav \bowtie^T_v$ $_v\vartheta^T_{f} (msg
(\sigma_{cond} (\tae \bowtie^T_{v_1} \tav \bowtie^T_{v_2} \tav))))$.
The temporal join is used to add the new properties to the output
since it may have different periods of validity.  For example, while
each vertex in \tg may remain unchanged for the whole duration,
aggregating vertex degrees would result in an attribute value for each
period of topology change.}

We support various aggregation functions $f_a$, including the standard
\{ \insql{count} | \insql{min} | \insql{max} | \insql{sum} \}, which
have their customary meaning.  We also support \{ \insql{any} |
\insql{first} | \insql{last} | \insql{set} | \insql{list} \}, which
are possible to compute because properties being reduced have temporal
information.  \insql{first} and \insql{last} refer to the value of a
property with the earliest/latest timestamp, while \insql{set} and
\insql{list} associate a key with a collection of values.

\eat{As an example, to compute vertex in-degrees, we can use
  $\agg{msg=(dst,p,1),red=count}{\ttt}$.  To compute a set of places
  that all close friends have visited in the past year, assuming there
  is a property \insql{places} on friend vertices and closeness of
  friendship property on edges:\\ $\agg{cond=dst.p \cap [2015,2016) \&
      a.close > 0.8,msg=(src,p,dst.places)}{\ttt}$.}

%To produce a valid \tg, \insql{agg} must invoke \coal{\tav'}.
%\julia{I don't think so: {\bf R2}: require reduce function.}

\subsection{Binary set operators}
\label{sec:algebra:binary}

We support temporal versions of the three binary set operators
intersection ($\cap^T$), union ($\cup^T$), and difference
($\setminus^T$).

\eat{These \tra operators are not schema robust~\cite{Dignos2012} ---
  their result is affected if the argument relation is extended by an
  additional attribute.  This presents a problem when executing the
  set operations over the \tav and \tae relations as there is no
  guarantee that a vertex or an edge with the same identity and at the
  same time instant has the same attribute set.  Thus all three
  operators require that the resolve primitive be invoked as part of
  the computation.}

To compute $\insql{T1} \cap^T \insql{T2}$, we set $\tv' = \tv_1 \cap^T
\tv_2$ and $\te' = \te_1 \cap^T \te_2$.  Next, we compute $\tav' =
\constr{\resolve{f_v}{\tav_1 \fullouterjoin^T_{v} \tav_2}}{\tv'}$ and
$\tae' = \constr{\resolve{f_e}{\tae_1 \fullouterjoin^T_{v1,v2}
    \tae_2}}{\te'}$.

To compute $\insql{T1} \cup^T \insql{T2}$, we set $\tv' = \tv_1 \cup^T
\tv_2$ and $\te' = \te_1 \cup^T \te_2$.  Next, we compute $\tav' =
\resolve{f_v}{\tav_1 \fullouterjoin^T_{v} \tav_2}$ and $\tae' =
\resolve{f_e}{\tae_1 \fullouterjoin^T_{v1,v2} \tae_2}$.  Note, that
unlike for $\cap^T$, it is not necessary to constraint $\tav'$ and
$\tae'$.

To compute $\insql{T1} \setminus^T \insql{T2}$, we set $\tv' = \tv_1
\setminus^T \tv_2$ and $\te' = \te_1 \setminus^T \te_2$.  Next, we
compute $\tav' = \constr{{\tav}'_1}{\tv'}$ and $\tae' =
\constr{{\tae}'_1}{\te'}$.

Note that both $\cap^T$ and $\cup^T$ require that resolve be invoked,
to reconcile the vertex/edge attributes associated with vertices/edges
in the temporal intersection of the inputs.

\eat{Note also that $\tav'$ and $\tae'$ are constrained w.r.t. $\tv'$ and
$\te'$, respectively, in the expressions above.}

 \eat{Then $\tve_1 \oplus_{f_v,f_e} \tve_2 = \{ \tv_1 \oplus \tv_2,
   \te_1 \oplus \te_2, \pi^T_{v,red(a_1,a_2)}(\tav_1
   \fullouterjoin^T_{v}
   \tav_2),$\\ $\pi^T_{v_1,v_2,red(a_1,a_2)}(\tae_1
   \fullouterjoin^T_{v_1,v_2} \tae_2) \}$, with all FK constraints on
   \tav and \tae enforced.}

\eat{As elsewhere, the default reduce function is \insql{set}.  In addition
to the functions defined in Section~\ref{sec:algebra:agg} we also
support \{ \insql{left} | \insql{right} \}, which select the attribute
of the left, resp. right, operand.}

%\subsection{Temporal graph intersection}
%\label{sec:algebra:join}
\eat{
The binary temporal graph intersection operation $\trga \cap \trgb$
computes a temporal join~\cite{Gao2005} of \trga and \trgb with the
predicate $\trga.p \cap \trgb.p \neq \emptyset$, producing a tuple for
each pair of representative graphs for which time periods intersect:
$\trga \cap \trgb = \{(g_1 \cap g_2, p_1 \cap p_2)~|~((g_1, p_1) \in
\trga \wedge (g_2, p_2) \in \trgb \wedge p_1 \cap p_2 \neq \emptyset
\}$.  The result of $g_1 \cap g_2$ is computed by intersecting the
sets of vertices and of edges of the graphs~\cite{GraphTheory}.  For
each vertex and edge in the result, we compute a {\em union} of their
bags of properties.% \julia{Figure with example.}
%
Algorithm~\ref{alg:inter} presents the evaluation of $\tvea \cap
\tveb$. We compute temporal joins over \tv and \te (lines 1, 2).  We
then compute \tav' and \tae' with temporal outer joins of the
corresponding relations (lines 3, 4).  Finally, we enforce foreign key
constraints on \te', \tav' and \tae' (lines 5, 6).
}

\begin{figure*}
%\centering
\begin{subfigure}{2.5in}
\includegraphics[width=2.5in]{figs/T2_rel.pdf}
\caption{T2.}
\label{fig:tg_t2}
\end{subfigure}
\begin{subfigure}{4.3in}
\includegraphics[width=4.3in]{figs/T1_union_T2_rel.pdf}
\caption{$T1 \cup^T T2.$}
\label{fig:tg_union}
\end{subfigure}
\begin{subfigure}{2.3in}
\includegraphics[width=2.3in]{figs/T1_inter_T2_rel.pdf}
\caption{$T1 \cap^T T2$.}
\vspace{-0.2cm}
\label{fig:tg_inter}
\end{subfigure}
\begin{subfigure}{2.3in}
\includegraphics[width=2.3in]{figs/T1_diff_T2_rel.pdf}
\caption{$T1 \setminus^T T2$.}
\vspace{-0.2cm}
\label{fig:tg_diff}
\end{subfigure}
\caption{Binary operators.}
\label{fig:binary}
\vspace{-0.2cm}
\end{figure*}

Consider \insql{T1} in Figure~\ref{fig:tg_ve} and \insql{T2} in
Figure~\ref{fig:tg_t2}.  Figure~\ref{fig:tg_inter} illustrates
\insql{T1} $\cap^T$ \insql{T2}.  Period $[2/15, 4/15)$ for $v_2$ is
  computed as a result of the join of $[2/15, 5/15)$ in \insql{T1} and
    [$2/15, 4/15)$ in \insql{T2}.  Only the vertices and edges present
      in both \tgs are produced, thus eliminating $v_3$ and $v_4$.
      Figure~\ref{fig:tg_union} illustrates \insql{T1} $\cup^T$
      \insql{T2}.  According to the definition of $\cup^T$, periods
      are split to coincide for any group, and thus the attribute
      values for e.g., $v_1$ have three distinct tuples.
      Figure~\ref{fig:tg_diff} shows the result of $\insql{T1}
      \setminus^T \insql{T2}$.  Vertex $v_1$ in the result is present
      before $2/15$ and after $6/15$, splitting one $v_1$ tuple in \tv
      of \insql{T1} into two temporally-disjoint tuples in \tv of the
      result (and similarly for \tav).

\eat{In addition to invoking reduce on the attribute relations for all
operations, it is required to invoke $\constr{\tav'}{\tv}$ and
$\constr{\tae'}{\te}$ for }

\eat{{\bf R1, R2}: for all set operators coalesce every relation in
$\ttt'$; {\bf R3}: enforce FK on $\tav'$ and $\tae'$ for difference,
intersection. {\bf R4}: require reduce function.}

\eat{Intersection and union may uncoalesce, while difference does not.
  Intersection and difference require FK enforcement for \tav and
  \tae, while union does not.}

%\subsection{Temporal graph union}
%\label{sec:algebra:outerjoin}

\eat{
The binary temporal graph union operation $\trga \cup \trgb$ computes
a temporal full outer join~\cite{Gao2005} of \trga and \trgb on the
predicate $\trga.p \cap \trgb.p $. For tuples $(g_1, p_1) \in \trga$
and $(g_2, p_2) \in \trgb$ for which $p_1 \cap p_2 \neq \emptyset$, we
compute $(g_1 \cup g_2, p_1 \cap p_2)$.  The result of $g_1 \cup g_2$
is computed by taking a {\em union} of the sets of vertices and of
edges of the graphs~\cite{GraphTheory}.  For each vertex and edge in
the result, we compute a {\em union} of their bags of properties.
Tuples from \trga (resp. \trgb) for which there does not exist a tuple
in \trgb (resp. \trga) for part or all of the validity period are
included in the result of the full outer join. 
}

\eat{
 $\trg_1 \cup \trg_2 = \{ (g, p) | (g_1, p_1) \in \trg_1 \wedge (g_2,
p_2) \in \trg_2 \wedge ((g = g_1 \cup g_2 \wedge p = p_1 \cap p_2
\wedge p_1 \cap p_2 \neq \emptyset) \vee (g = g_1 \wedge p = p_1 - p_2
\wedge \nexists p \in \trg_2 = p_1 - p_2) \vee (g = g_2 \wedge p = p_2
- p_1 \wedge \nexists p \in \trg_1 = p_2 - p_1))\}$.  Similar to
temporal intersection, temporal union is essentially an outer
theta-join of $\trg_1$ and $\trg_2$ with a $p_1 \cap p_2$ predicate.
We use the standard graph union definition based on set theory, which
computes unions of the vertex and edge sets from the two
operands~\cite{GraphTheory}.}

\eat{
Algorithm~\ref{alg:union} presents the evaluation of $\tvea \cup
\tveb$.  We compute temporal outer joins over the corresponding \tv,
\te, \tav and \tae.
}

\eat{\begin{algorithm}[t]
\caption{Temporal graph union in \tve.}
\begin{algorithmic}[1]
\REQUIRE $\tvea, \tveb$.\\
\STATE $\tv' = \tv_1 \fullouterjoin^T_v \tv_2$\\
\STATE $\te' = \te_1 \fullouterjoin^T_{v1,v2} \te_2$\\
\STATE $\tav' = \cl (\pi_{v,p,\tav_1.a \cup \tav_2.a}\tav_1 \fullouterjoin^T_v \tav_2)$\\
\STATE $\tae' = \cl (\pi_{v_1,v_2,p,\tae_1.a \cup \tae_2.a}\tae_1 \fullouterjoin^T_{v1,v2} \tae_2)$\\
\RETURN new $\tve (\tv';\te';\tav';\tae')$\\
\end{algorithmic}
\label{alg:union}
\end{algorithm}
}

%\subsection{Temporal graph difference}
%\label{sec:algebra:diff}

\eat{
The binary temporal graph difference operation $\trga \setminus \trgb$
computes a temporal left outer join~\cite{Gao2005} of \trga and \trgb
on the predicate $\trga.p \cap \trgb.p$.  For tuples $(g_1, p_1) \in
\trga$ and $(g_2, p_2) \in \trgb$ for which $p_1 \cap p2 \neq
\emptyset$, we compute $(g_1 \setminus g_2, p_1 \cap p_2)$.  The
result of $g_1 \setminus g_2$ is computed by taking a {\em set
  difference} of the sets of vertices and of edges of the graphs.  For
each vertex and edge in the result, we compute a {\em union} of their
bags of properties.  Tuples in \trga for which there does not exist a
tuple in \trgb for part or all of the validity period are included in
the result of the left outer join.
}
\eat{
Algorithm~\ref{alg:diff} presents the evaluation of $\tvea \setminus
\tveb$.  We compute temporal left outer joins over the corresponding
\tv and \te (lines 1,2).  We then compute $\tav'$ and $\tae'$ with
temporal outer joins of the corresponding relations (lines 3, 4).
Finally, we enforce foreign key constraints on $\te'$, $\tav'$, and
$\tae'$ (lines 5, 6).
}

\eat{\begin{algorithm}[b]
\caption{Temporal graph difference in \tve.}
\begin{algorithmic}[1]
\REQUIRE $\tvea, \tveb$.\\
\STATE $\tv' = \tv_1 \leftouterjoin^T_v \tv_2$\\ 
\STATE $\te' = \te_1 \leftouterjoin^T_{v_1,v_2} \te_2$\\ 
\STATE $\tav' = \cl (\pi_{v,p,\tav_1.a \cup \tav_2.a}\tav_1 \fullouterjoin^T_v \tav_2)$\\
\STATE $\tae' = \cl (\pi_{v_1,v_2,p,\tae_1.a \cup \tae_2.a}\tae_1 \fullouterjoin^T_{v_1,v_2} \tae_2)$\\
\STATE enforce foreign keys on $\tav'$ w.r.t. $\tv'$\\ 
\STATE enforce foreign keys on $\tae'$ w.r.t. $\te'$\\ 
\RETURN new $\tve (\tv';\te';\tav';\tae')$\\
\end{algorithmic}
\label{alg:diff}
\end{algorithm}
}

\subsection{Node creation}
\label{sec:algebra:ncreate}

We argued in the introduction that it is interesting and insightful to
analyze an evolving graph at different levels of granularity.  For
example, the user may want to aggregate multiple consecutive
representative graphs into a single representative graph, coarsening
the granularity, or to predefine temporal resolution and look at the
graph at that scale, irrespective of whether this resolution happens
to be finer or coarse than the natural evolution rate of the graph.
For this, we introduce a node creation operator which is similar to
the {\em moving window temporal aggregation} in temporal relational
algebra.  Our approach is inspired by stream aggregation work
of~\cite{Li2005}, adopted to graphs, and by generalized quantifiers
of~\cite{Hsu1995}.

Node creation is denoted $\ncr{G_V}{W,Q_V,Q_E,red}{\ttt}$,\\ where
$G_V$ are the grouping attributes, $W$ is the window specification,
$Q_V$ and $Q_E$ are vertex and edge quantifiers, and $red$ is the set
of reduce functions.  It produces a consolidated evolving graph with
specific temporal granularity.

{\em Grouping attributes} $G_V$ are vertex properties by which
vertices are grouped into new entities, similar to \insql{GROUP BY}
clause in SQL.  Since node creation requires new identifiers, the
combination of the grouping properties can be used in a mechanism
equivalent to a Skolem function.  The simplest, default grouping
attribute is the $vid$ of the vertex.

{\em Window specification} $W$ is of the form
$n~\{unit|\insql{changes}\}$, where $n$ is an integer, and $unit$ is a
time unit, e.g., $10~min$, $3~years$, or any multiple of the usual
time units.  Window specification of the form $n~\insql{changes}$
defines the window in terms of change over \trg.\eat{ (which may be
  computed from the \tve representation, see
  Section~\ref{sec:model:switch}).}  For example,
$W=3~\insql{changes}$ will aggregate sequences of 3 representative
graphs into 1.  Window boundaries are computed left-to-right, i.e.,
from least to most recent.  The right-most window may correspond to
fewer than $n$ representative graphs from the input.
%
Our window specification by change is similar to slide-by-row window
in stream aggregation~\cite{Li2005}.  Note that, because \tg algebra
is compositional, we do not support node creation with overlapping
windows, because it does not produce a valid \tg.  To see why this is
so, consider applying a sliding window of 3 months range with 1 month
slide to graph \insql{T} in Figure~\ref{fig:tg_rg}.  We would produce
the following tuples for $v_1$: $(v_1, [1/15, 4/15), a_1)$, $(v_1,
  [2/15, 5/15), a_2)$, $(v_1, [3/15, 6/15))$, and so on, which clearly
      violates the temporally coalesced requirement in
      definition~\ref{tg}.

Similar to~\cite{Li2005} we support creation simultaneously by time
and by non-temporal attributes (e.g., vertex properties).  If the
window specification is one change, then the operation devolves into
pure structural reduce or node creation, as classified by
Wood~\cite{Wood2012}.  If the grouping attribute is the vertex $vid$,
then the operation is purely temporal, with no structural aspect.

{\em Quantifiers} $Q_V$ and $Q_E$ are of the form \{ \insql{all} |
\insql{most} | \insql{at least} $n$ | \insql{exists} \}, where $n$ is
a decimal representing the percentage of the time during which an
entity (vertex or edge) existed, relative to the duration of the
window. Note that \insql{exists} is the default quantifier for
vertices and edges.  Quantifiers are useful for producing different
kinds of representative graphs.  For example, to produce
representative graphs with only strong connections over a volatile
evolving graph, we may want to only include vertices that span the
entire time window ($Q_V=\insql{all}$), and edges that span a large
portion of the window ($Q_E=\insql{most}$).
 
The optional reduce functions compute new
values for vertex and edge properties representative of
the whole window, e.g., $any(name), last(school), sum(cnt)$.
%
 
\eat{Key-value pairs for vertex and edge properties for which no
aggregation functions are specified, are collected into a bag
corresponding to the entity in the result.  These can be subsequently
transformed with $map^T$ (Section~\ref{sec:algebra:project}).}

\eat{ 
Temporal aggregation over \tve follows the outline of
Algorithm~\ref{alg:op}, but requires an additional step, and is
revisited in Algorithm~\ref{alg:agg_ve}.
%
}

We compute group periods based on window specification: $P =
\textsf{computePeriods}(W, \tv, \te, \tav, \tae)$.  We use temporal
aggregation and selection to evaluate $Q_V$ on each group in $\tv$:
$\tv' = \sigma_{P,Q_V}( _{G_V}\vartheta^T (\tv \leftouterjoin^T
\tav))$ and similarly for $\te$: $\te' = \sigma_{P,Q_E}(
_{G_V}\vartheta^T (\te \bowtie^T_{v_1=v} \tav \bowtie^T_{v_2=v}
\tav))$.  The edge triplets, obtained through three-way temporal join
of \tae with \tav are required to aggregate edges by $G_V$.  To
compute attribute relations we compute temporal aggregation with the
reduce functions and enforce FK constraints: $\tav' =
~_{G_V}\vartheta^T_{red}(\tav)$, $\tae' =
~_{G_V}\vartheta^T_{red}(\tae \leftouterjoin^T_{v_1=v} \tav
\leftouterjoin^T_{v_2=v})$.

\eat{
Node creation over \trg is computed by first calculating time periods
from $W$ and \trg, and then reducing and combining the representative
graphs directly.
}

\eat{\begin{algorithm}[t!]
\caption{Node creation in \tve.}
\begin{algorithmic}[1]
\REQUIRE \tve (\tv;\te;\tav;\tae), window specification $W$, vertex
quantifier $Q_V$, edge quantifier $Q_E$, vertex aggregate function
$A_V$, vertex aggregate function $A_E$.\\
\STATE $P = \textsf{computePeriods}(W, \tv, \te, \tav, \tae)$\\
\STATE  $\tv' = \cl (_{G_V}\vartheta_{P,Q_V}(\tv))$\\
\STATE  $\te' = \cl (_{G_V}\vartheta_{P,Q_E}(\te))$\\
\STATE  $\tav' = \cl (_{G_V}\vartheta_{P,A_V}(\tav))$\\
\STATE  $\tae' = \cl (_{G_V}\vartheta_{P,A_E}(\tae))$\\
\STATE  follow steps 5-7 of Algorithm~\ref{alg:op}\\
%\STATE  enforce foreign keys on $\te'$ w.r.t. $\tv'$\\
%\STATE  enforce foreign keys on $\tav'$ w.r.t. $\tv'$\\
%\STATE  enforce foreign keys on $\tae'$ w.r.t. $\te'$\\
\RETURN new $\tve (\tv';\te';\tav';\tae')$\\
\end{algorithmic}
\label{alg:agg_ve}
\end{algorithm}
}

Figure~\ref{fig:tg_agg1} illustrates node creation by time
($W=3~\textsf{months}$), and Figure~\ref{fig:tg_agg2} --- by change
($W=3~\textsf{changes}$).  Figure~\ref{fig:tg_agg3} illustrates
structural reduce only ($W=1~\textsf{change}$), and
Figure~\ref{fig:tg_agg4} both structural and temporal
($G_V=\textsf{school}, W=3~\textsf{months}$).  All four are applied to
\insql{T1} in our running example, and list the same quantifiers
(\insql{all} for vertices and \insql{exists} for edges) and reduce
functions (\insql{first} for vertex and edge properties).  $v_2$ is
present in the result in Figure~\ref{fig:tg_agg1} starting at $4/15$
because it did not exist for the entirety of the first window, while
in Figure~\ref{fig:tg_agg2} it is produced starting $6/15$.  In
Figure~\ref{fig:tg_agg3} vertices $v1$ and $v3$ create a single new
vertex $v1$ representing the institution.  A subsequent \insql{map}
operation to produce a new name attribute and a count of people would
produce a more meaningful final result.

\begin{figure*}[t]
%\centering
\begin{subfigure}[b]{0.5\textwidth}
\includegraphics[width=3.2in]{figs/agg1.pdf}
\caption{By time: $W=3~\textsf{months}, G_V=\textsf{vid}$.}
\label{fig:tg_agg1}
\end{subfigure}
\begin{subfigure}[b]{0.5\textwidth}
\includegraphics[width=3.2in]{figs/agg3.pdf}
\caption{Grouped by attribute: $W=1~\textsf{change}, G_V=\textsf{school}$.}
\label{fig:tg_agg3}
\end{subfigure}
\begin{subfigure}[b]{0.5\textwidth}
\includegraphics[width=3.2in]{figs/agg2.pdf}
\caption{By change: $W=3~\textsf{changes}, G_V=\textsf{vid}$.}
\label{fig:tg_agg2}
\end{subfigure}
\begin{subfigure}[b]{0.5\textwidth}
\includegraphics[width=3.2in]{figs/agg4.pdf}
\caption{By time with grouping: $W=3~\textsf{months}, G_V=\textsf{school}$.}
\label{fig:tg_agg4}
\end{subfigure}
\caption[]{Node creation, $Q_V=\insql{all}$, $Q_E=\insql{exists}$,
  $A_V=\insql{first}$, $A_E=\insql{first}.$}
\label{fig:tg_agg}
\vspace{-0.5cm}
\end{figure*}

\eat{Node creation may uncoalesce and requires FK enforcement.}

{\bf R1, R2}: coalesce every relation in $\ttt'$; {\bf R3}: enforce FK
on $\tav', \te', \tae'$; {\bf R4}: require reduce function.

\eat{ Our aggregation quantifiers are inspired by generalized
  quantifiers of~\cite{Hsu1995} with n-place delimiters.  $Q(R)$ as a
  Boolean-valued function of a relation''~\cite{Hsu1995}.  A
  quantifier contains an n-place determiner, e.g., ``at least one
  vertex in each window for each group'' is a 2-place determiner
  quantifier.  \tg algebra supports determiners from the set
  $\{at\ least\ one, all, most, at\ least\ n\}$, where $n$ is an
  integer representing a ratio.  $all$ is a usual universal quantifier
  that in standard SQL can be achieved with the use of two \insql{NOT
    EXISTS}.}

\subsection{Edge creation}
\label{sec:algebra:ecreate}

Edge creation operator outputs a new graph with edges based on the two
input \tgs.  Let $\ecr{\ttt_1}{q,red}{\ttt_2}$ be an edge creation
operator, where $q$ is a conjunctive query over constituent relations
of $\tve_1$ and $\tve_2$ and $red$ is a reduce function. $q$ must
return a valid temporal relation $(v_1, v_2, a_1, a_2)$.  The reduce
function is used to compute the final $\tae'$ relation.
$\ecr{\ttt_1}{q,red}{\ttt_2} = \{ \tv', \te', \tav', \tae' \}$, where
$\tae' = \sigma^T_{v_1,v_2,red(a_1,a_2)}(q(\ttt_1, \ttt_2))$ subject
to FK constraint from $\tv_1 \cup^T \tv_2$, $\te' =
\sigma^T_{v_1,v_2}(\tae')$, \tv' is a subset of $\tv_1 \cup^T \tv_2$
such that it contains only vertices with edges in $\te'$, and $\tav'$
is an empty relation.  Intuitively, edge creation returns a new \tg
from nodes of $\ttt_1$ and $\ttt_2$ with no attributes, connected by
edges determined by $q$.

Edge creation has several important applications.  In graph theory, a
graph join of two undirected unlabeled disjoint graphs is defined as
the union of the two graphs and additional edges connecting every
vertex in graph one with each vertex in graph two.  We can obtain a
graph join by the application of edge creation with $q = $ a temporal
cartesian product of $\tv_1$ and $\tv_2$.
SocialScope~\cite{Amer-Yahia2009} defines a nontemporal graph
composition operator which produces a graph induced by edges that are
composed from edges in the two operands connected by a common vertex
with a directional condition.  In \ql temporal graph composition can
be computed using node creation of \ttt with itself and a $q = $ a
temporal theta-join of $\tae$ and $\tae_2$.  This allows computation
of friend-of-friend edges, which, if applied k times, can answer k-hop
queries.  Since $q$ can include predicates over the timestamps, edge
creation can also compute journeys.  A journey is a path in the
evolving graph with non-decreasing time
edges~\cite{Ferreira2004,Casteigts2011}.  By adding a temporal
condition to the theta-join of $\tae_1$ and $\tae_2$ we can obtain
journeys similar to time-concurrent paths.

\julia{Example of edge transpose goes here.}

Note that edge creation is not additive, it produces {\em new} edges.
To add these edges to the original graph, a subsequent union must be
performed.

\eat{Graph composition operator in our algebra is a temporal extension of
the composition operator in SocialScope~\cite{Amer-Yahia2009}.  It
produces a graph induced by edges that are composed from edges in the
two operands for any time point when they coexisted.  The value of the
new edge attributes is determined by the resolve function, similar to
the set based operators.}

\eat{
Let $\odot_{\delta,r}$ be a composition operator, where $\delta$ is a
directional condition pair $d_1=v_1|v_2, d_2=v_1|v_2$ and $r$ is a
resolve function.  Then $\ttt_1 \odot_{\delta,r} \ttt_2 = \{ \tv',
\te', \tav', \tae' \}$, where $\forall (v_x,v_z,p) \in \te' \exists
(d_1,v_x,p_1) \in \te_1 \wedge (d_2,v_z,p_2) \in \te_2 \wedge p=p_1
\cap p_2$, \tv' contains only vertices with edges in \te', with FK
constraint enforced on \tav' from \tv', and $\forall (v_x,v_z,p,a) \in
\tae' \exists (d_1,v_x,p_1,a_1) \in \tae_1 \wedge (d_2,v_z,p_2) \in
\tae_2 \wedge p=p_1 \cap p_2 \wedge a=r((a_1,p_1),(a_2,p_2))$.
}

\eat{For example, to create edges between vertices that have two degrees of
separation, i.e. friends of friends, we can compose the graph with
itself with $d_1=v_2$ and $d_2=v_2$.  }

{\bf R1, R2}: coalesce $\te'$ and $\tae'$; {\bf R3}: constraint $\te'$
on $\tv'$, $\tv'$ on $\te'$ (to remove nodes with no edges), and
$\tae'$ on $\te'$; {\bf R4}: require reduce function.

\input{analytics}

%\input{example}
