\section{Related Work}
\label{sec:related}

{\bf Querying and analytics.} There has been much recent work on
analytics for evolving graphs,
see~\cite{DBLP:journals/csur/AggarwalS14} for a survey. This line of
work is synergistic with ours, since our aim is to provide systematic
support for scalable querying and analysis of evolving graphs.

Several researchers have proposed individual queries, or classes of
queries, for evolving graphs, but without a unifying syntax or general
framework.  Kan et al.~\cite{Kan2009} propose a query model for
discovering subgraphs that match a specific spatio-temporal pattern.
Chan et al.~\cite{Chan2008} query evolving graphs for patterns
represented by waveforms.  Semertzidis et al.~\cite{Semertzidis2015}
focus on historical reachability queries.

Our work shares motivation with Miao et
al.~\cite{DBLP:journals/tos/MiaoHLWYZPCC15}, who developed an
in-memory execution engine for temporal graph analytics called
ImmortalGraph.  Unlike Miao et al., who focus on in-memory layout and
locality-aware scheduling mechanisms, we work in a distributed
processing environment.  A further difference is that our work is in
scope of Apache Spark, a widely-used open source platform, while
ImmortalGraph is a proprietary stand-alone prototype.

\eat{
Our work differs from query processing on dynamic graphs
(e.g.,~\cite{Mondal2012}), where the history of changes is not
important, and from mining evolving graph streams
(e.g.,~\cite{Liu2010}), where the focus is on discovering significant
changes.}

{\bf Temporal SQL.}  We borrow the definition of a time period from
Temporal SQL defined in the SQL:2011
standard~\cite{DBLP:journals/sigmod/KulkarniM12}.  We also support the
same temporal predicates in the \insql{TWhere} clause, such as
\insql{overlaps}, \insql{precedes}, \insql{contains}.  This is where
similarities between \ql and SQL end.  SQL does not define temporal
aggregation, nor support temporal intersections and unions.  In \ql,
temporal aggregation is a key opreation that supports investigating
periodic trends of different resolution.  In addition, our support for
snapshot analytics is inherently graph-centric.  Users can register
their own snapshot analytics through special Pregel-style UDFs.

{\bf Data representation.}\eat{ Another important area of research is
  efficient storage, retrieval and in-memory representation of
  evolving graphs.  }The basic building block in \ql is a snapshot,
which naturally limits the resolution at which changes can be
retrieved. This deliberate choice is in contrast with delta-based
approaches~\cite{Khurana2013,Koloniari2012,DBLP:journals/tos/MiaoHLWYZPCC15}.

Khurana and Deshpande~\cite{Khurana2013} investigate efficient
physical representations using deltas to support snapshot retrieval.
Their in-memory GraphPool maintains a single representation of all
snapshots, and is thus similar to our OneGraph.\eat{  GraphPool goes
further and stores only dependencies from a materialized snapshot when
deltas are small.  We do not take this step because evaluation of
queries involving multiple snapshots, such as \insql{TGroup}, requires
fully materialized views in memory. The snapshot group method
of~\cite{DBLP:journals/tos/MiaoHLWYZPCC15} is similar to DeltaGraph
in~\cite{Khurana2013}.}

Ren et al.~\cite{Ren2011} develop an in-memory representation of
evolving graphs based on representative graphs for sets of snapshots.
\eat{Representative graphs can be computed using structural
  aggregation in \ql, and so this work provides additional motivation
  for our temporal aggregation and join operators.}  Our OneGraph can
be thought of as a representative graph for the whole selected time
period, while HybridGraph is a sequence of representative graphs.\eat{  In
the future we may consider a hybrid approach similar
to~\cite{Ren2011}, materializing multiple OneGraphs for different sets
of snapshots if a single representation becomes too dense.}

Semertzidis et al.~\cite{Semertzidis2015} develop a version graph,
where each node and edge are annotated with the set of time intervals
in which they exist.  This is similar to our OneGraph, but we also
store non-topological attributes.\eat{  We also do not compress consecutive
existence intervals with the same value into one, because this would
make \insql{TGroup} and snapshot analytics more complex and more
difficult to parallelize.}

Boldi et al.~\cite{Boldi2008} present a space-efficient non-delta
approach for storing a large evolving Web graph that they harvested.
\eat{Their approach for encoding the presence or absence of nodes and
  edges at each time interval using bits is similar to our MultiGraph
  and its use of BitSets.  The primary difference is that t'}Their
work represents purely topological information and does not address
vertex and edge attributes.

\eat{
% We said this in experiments
Miao, et al.~\cite{DBLP:journals/tos/MiaoHLWYZPCC15} demonstrate that
there is a trade-off between temporal and spatial locality based on the
type of query.  Their solution is to keep multiple data replicas on
disk and pick the better one for the type of query requested.  In our
work we also explore the trade-offs between structural and temporal
locality.}  \eat{However, our focus is on in-memory query evaluation and not
on on-disk layout.}

{\bf Distributed frameworks.}  We build upon
GraphX~\cite{DBLP:conf/osdi/GonzalezXDCFS14}, which provides an API
for working with regular graphs (snapshots) in Apache Spark, but
without the time dimension.  To improve performance, we modified the
GraphX graph loading code, enabling concurrent distributed multi-file
loading with a tuned number of partitions.
%
\eat{We use built-in GraphX partitioning and develop additional vertex-cut
strategies that incorporate the temporal dimension.}
%
\eat{Another relevant framework is SparkSQL~\cite{Xin2013Shark}, which
provides mid-query optimization of distributed execution.  Mid-query
optimization is in our immediate plans for \ql.  In SparkSQL tables
to be joined can be co-partitioned at creation time.  This is similar
to what our data structures and partition strategies achieve for
\insql{TGroup} and temporal join.}
%
Lin et al.~\cite{DBLP:conf/www/LinGR14} proposed Warcbase, an
infrastructure for exploration and discovery of Web archives built on
HBase.  Their work shares motivation with ours, but the technical
choices are fairly different from ours.  Most importantly, we work
with Apache Spark, a higher-level abstraction over MapReduce, and
define a declarative query language on top of Apache Spark.

