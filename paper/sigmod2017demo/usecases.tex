\section{\ql by example}
\label{sec:cases}

We now illustrate the salient features of \ql with examples.  For each
example, we give a declarative query, and a corresponding \tga
expression.  For readability, we start by presenting single-operator
queries, and then combine them into a complex query.

All queries presented here will be available to \sys users during the
demonstration, as described in Section~\ref{sec:demo}.  We do not list
performance results here due to space constraints, and point an
interested reader to~\cite{PortalarXiv2016}, where system performance
is evaluated thoroughly.  We note that all queries described here, and
many others, execute in interactive time.

All queries in this section analyze one typical kind of an evolving
graph, namely, an interaction network, which represents people as
vertices, and interactions between them such as messages,
conversations and endorsements, as edges.  Information describing
people and their interactions is represented by vertex and edge
attributes, respectively.  An example of a publicly available
interaction network is the wiki-talk dataset
(\url{http://dx.doi.org/10.5281/zenodo.49561}), containing messaging
events among Wikipedia contributors over a 13-year period.
Information available about the users includes their username, group
membership, and the number of Wikipedia edits they made.  Messaging
events occur when users post on each other's talk pages.

%Communities over time.
Interaction networks are sparse because edges are short-lived.  As
part of exploratory analysis, we can consider the network at different
temporal resolutions, run a community detection algorithm, e.g.,
compute the connected components of the network, and then consider the
number of connected components and their sizes.  

\eat{To see whether communities form and at what time scale, we can vary
the time scale and compute communities, e.g. through connected
components detection, group the vertices by the community they form
and calculate their size.  We can filter out vertices that represent
communities below a reasonable threshold, for example of size smaller
than two.}

\eat{This example demonstrates a need to compute graph-wide analytics
  such as connected components for each point in time, create new
  vertices that represent some aspect of data of existing vertices,
  and compute subgraphs.  Graph-wide analytics on evolving graphs have
  been proposed previously in ImmortalGraph~\cite{Miao2015} and
  G*~\cite{Labouseur2015}, including PageRank, weakly connected
  components, and source-source shortest path.}

\eat{{\bf Question:} In a sparse communication network, on what time scale
can we detect communities?}

\begin{example}
\label{ex:load}

We can load the dataset with the following command:

\begin{small} 
\begin{verbatim}
Create TGraph wiki As { Load From "path/to/data" }
\end{verbatim}
\end{small}

\end{example}

We use the Apache Parquet format for on-disk storage, with one archive
for vertices and another for edges, temporally coalesced.  We provide
a loader utility that can initialize any of our available physical
representations (see~\cite{PortalarXiv2016}), from Apache Parquet
files on HDFS or on local disk.

\begin{example}
\label{ex:slice}

Select a 5-year subset of the data:

\begin{small} 
\begin{verbatim}
Create TGView T1 As { 
   VSelect * ESelect *
   From wiki
   When start>='2010-01-01' AND end<'2015-01-01'}
\end{verbatim}
\end{small}

The corresponding algebraic expression in \tra uses the common
temporal slice operator: $\ttt_1 = \slice{[2010,2015)}{wiki}$.

\end{example}

\begin{example}
\label{ex:nodecrt}

Compute a temporally aggregated view of the graph into 6-months
windows.  A window includes vertices and edges that correspond to
users who communicated regularly: a vertex and an edge are each
present if they exist in every snapshot during the 6-month period.

\begin{small} 
\begin{verbatim}
Create TGView T2 As { 
   VSelect * ESelect *
   From T1
   TGroup By 6 months
   VExists always EExists always }
\end{verbatim}
\end{small}

This query corresponds to a \tra expression that invokes window-based
node creation, an evolving graph operation similar to moving window
temporal aggregation for relations:
$\ttt_2 = \insql{node}^T_w(\mathsf{w=6~mon},\mathsf{q_v=always},\mathsf{q_e=always},\ttt_1)$.

\end{example}

Node creation enables the user to analyze an evolving graph at
different levels of granularity.  This operator comes in two variants
--- based on temporal window (Example~\ref{ex:nodecrt}) or based
on vertex attributes, illustrated next.

\begin{example}
\label{ex:cc}

Compute connected components at each time point.  This is an
  example of a Pregel-style analytic invocation over an evolving
  graph.

\begin{small} 
\begin{verbatim}
Create TGView T3 As { 
   VSelect components() as comp, *
   Eselect *
   From T2 }
\end{verbatim}
\end{small}

This query correspond to the following \tra expression:
$\ttt_3 = \insql{pregel}^T_{cc} (\mathsf{pname=comp}, \ttt_2)$.

\end{example}

\eat{
Note the use of $*$ after invocation of the components analytic.  With
the property model, different nodes may have different properties, so
listing them all may be burdensome for the user.}

\eat{ We need to compute graph-wide analytics such as connected
  components for each point in time.  Graph-wide analytics on evolving
  graphs have been proposed previously in
  ImmortalGraph~\cite{Miao2015} and G*~\cite{Labouseur2015}, including
  PageRank, weakly connected components, and source-source shortest
  path.}

\begin{example}
\label{ex:nodecra}

Generate a new graph, in which a vertex corresponds to a connected
component, and compute the size of the connected component.  

\begin{small} 
\begin{verbatim}
Create TGView T4 As { 
   VSelect count(*) as cnt  ESelect *
   From T3
   VGroup By comp }
\end{verbatim}
\end{small}

\end{example}

This operation allows the user to generate a \tg in which a vertex
corresponds to a group of vertices in the input that agree on the
values of all grouping attributes.  An edge in the output is
introduced between vertices $g_1$ and $g_2$ if some pair of vertices
$v_1$ and $v_2$ in the input \tg were connected by an edge, $v_1$ is
in group $g_1$ and $v_2$ is in group $g_2$.  We do not add any
self-loops to the output \tg. The corresponding \tra expression is
$\ttt_4 = \insql{node}^T_a(\mathsf{g=comp,f_v=count(1)},\ttt_3)$.

\eat{Vertices of the input are partitioned on their values of the
  grouping attributes.  An edge is created between a pair of vertices
  in the output if some two input Partitioning of the vertices also
  induces a partitioning of the edges.}

\begin{example}
\label{ex:subg}

Filter out vertices that represent communities too small to be of
interest (e.g., of 1-2 people).  

\begin{small} 
\begin{verbatim}
Create TGView T5 As {
   VSelect * ESelect *
   From T4
   VWhere cnt > 2 }
\end{verbatim}
\end{small}

This query corresponds to a \tra expression that invokes the vertex
subgraph operation $\ttt_5 = \subv{\mathsf{v.a.count > 2}}{\ttt_4}$.

\end{example}

The queries of Examples~\ref{ex:load} --- \ref{ex:subg} can be
combined into a single complex query:

\begin{small}
\begin{verbatim}
VSelect * ESelect *
From (
    VSelect count(*) as cnt  ESelect *
    From (
        VSelect components() as comp, * ESelect *
        From ( Load From "path/to/data" }
        TGroup By 6 months
        VExists always EExists always
        When start>='2010-01-01' AND end<'2015-01-01' )
    VGroup By comp)
VWhere cnt > 2 
\end{verbatim}
\end{small}

In an individual \ql query, slice and subgraph operations
(\insql{When}, \insql{VWhere}, and \insql{EWhere}) take precedence
over the other operations, followed by node creation (\insql{TGroup}
and \insql{VGroup}), and then by aggregation (illustrated in
Example~\ref{ex:agg}) and analytics.  Multiple orders of execution are
possible in queries that include node creation by both temporal window
and vertex attributes, and in queries that join two \tgs by means of
an intersection or a union (illustrated in Example~\ref{ex:union}
below), and execute node creation, selection or subgraph on the
result.  We discuss this further in Section~\ref{sec:sys}.

\eat{The order of precedence in a single statement is selection and
  slice (\insql{vwhere}, \insql{ewhere}), node creation, analytics,
  map, and then binary operations.  Multiple orders of execution are
  possible since slice can be performed at any point, but it is most
  efficient to perform slice first to reduce the amount of data for
  further evaluation.}

Another use case demonstrates the remaining operations of \tga.  DBLP
and arXiv datasets contain co-authorship information and can provide
interesting insights into the CS research community at large.  Nodes
represent authors, and edges --- a joint publication between a pair of
authors.

\begin{example}
\label{ex:union}

Assuming that author ids are drawn from the same domain, i.e., are
assigned consistently in DBLP and arXiv, we can combine the two
datasets for a more comprehensive view using temporal graph union:

\begin{small}
\begin{verbatim}
Create TGView T6 As {
   VSelect left(name)  ESelect max(cnt)
   From dblp Union arXiv }
\end{verbatim}
\end{small}

Note that, unlike in relational algebra, \tga union requires aggregate
functions to resolve multiple property values for the same node or
edge.  The \insql{left} function takes the value of the vertex
property \insql{name} from the DBLP dataset (the left operand), if a
vertex exists in both DBLP and arXiv. The corresponding \tga
expression is $\ttt_6 =
dblp~\cap^T~arXiv(f_v=left(name),f_E=max(cnt))$.

\end{example}

\begin{example}
\label{ex:agg}

Finally, we compute an in-degree of each vertex during each time
point.  This is an example of the {\em aggregation} operation, a
common operation on non-temporal graphs, as defined by the taxonomy of
Wood~\cite{Wood2012}.  Aggregation computes a value for each vertex
based on its neighbors.

\begin{small} 
\begin{verbatim}
Create TGView T7 As { 
   VSelect count(*) as deg, * ESelect *
   From T6
   Aggregate Right }
\end{verbatim}
\end{small}

This query corresponds to a \tra expression that uses temporal
aggregation, listed here with default arguments: $\ttt_7 =
\insql{agg}^T(\mathsf{dir=right},\mathsf{f_m=1},\mathsf{f_a=count},\mathsf{pname=deg},\ttt_6)$.

\end{example}

\eat{Besides the examples above, graph queries commonly include retrieving
a specific node (which can be accomplished through a subgraph) and
k-hop neighborhood of a node.  While general transitive closure
requires recursion, which we do not support, k-hop neighborhoods can
be computed using composition operations like the one defined in
SocialScope~\cite{Amer-Yahia2009}.  We provide temporal versions of
subgraph and generalized edge creation.  Additionally, if multiple
sources of the same graph are available, it is useful to combine or
compare them, which dictates the need for temporal set-theoretic
operators.}

\eat{In Section~\ref{sec:algebra} we formally define the operators of our
graph algebra.  In Section~\ref{sec:exp} we return to these three use
cases. 
}

