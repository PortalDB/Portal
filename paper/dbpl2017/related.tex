\section{Related Work}
\label{sec:related}

{\bf Conceptual models.}  While the temporal models in the relational
literature are very mature, the same cannot be said for the evolving
graphs literature.  Evolving graph models differ in what time model
they adopt (point or interval), what top-level entities they model
(graphs or sets of nodes and edges), whether they represent topology
only or attributes or weights as well, and what types of evolution are
allowed.  All evolving graph models require node identity, and thus
edge identity as well, to persist across time.

The first mention of evolving graphs that we are aware of is by Harary
and Gupta~\cite{Harary1997} who informally proposed to model the
evolution as a sequence of static graphs\eat{, as depicted in
  Figure~\ref{fig:snapshots}}.  This model has been predominant in the
research literature
since~\cite{Ferreira2004,Kan2009,Khurana2013,Lerman2010,Ren2011,Semertzidis2015},
with various restrictions on the kinds of changes that can take place
in the graph evolution.  For example, Khurana and Deshpande use this
model but a node, once removed, cannot reappear~\cite{Khurana2013}.
In~\cite{Labouseur2015,Ren2011} there is no notion of time at all,
only a sequence of graphs.  \eat{In~\cite{Borgwardt2006}
  and~\cite{Kan2009} the time series of graphs represent topology
  only, with no attributes, and only edges can vary with time, while
  the nodes remain unchanged.  Ferreira's model~\cite{Ferreira2004}
  allows both node and edge evolution, but again, only restricted to
  topology.}

The advantages of the snapshot sequence model are that it is simple
and if snapshots are obtained by periodic sampling, which is a very
common approach, it accurately represents the state at that point
without making statements about other unknowable times.  The biggest
problem with the snapshot sequence as the underlying conceptual model
is that it restricts the range of operations that can be naturally
expressed.  For example, it is impossible to select a subgraph over a
snapshot sequence using a temporal predicate, because each snapshot is
nontemporal and independent of the others.  Stated formally, the
snapshot sequence model lacks the extended snapshot reducibility
property.

Other attempts at adding time as data have encountered issues of
scalability~\cite{Cattuto2013}, in addition to the difficulties placed
on the user to phrase correct queries.

{\bf Evolving graph queries.}  Evolving graph analysis and mining have
been receiving increased attention over the past few years.  Several
researchers have proposed individual queries, or classes of queries,
for evolving graphs, but without a unifying syntax or general
framework.

The proposed operators can also be divided into temporal, i.e., those
that return a temporal result, and nontemporal.

Temporal operators include retrieval of version data for a particular
node and edge~\cite{Khurana2016}, of
journeys~\cite{Casteigts2011,George2009}, subgraph by time or
attributes~\cite{Huo2014,Khurana2016}, snapshot
analytics~\cite{Khurana2016,Labouseur2015,Miao2015}, and computation
of time-varying versions of whole-graph analytics like maximal
time-connected component~\cite{Ferreira2004} and dynamic graph
centrality~\cite{Lerman2010}.

Nontemporal operators are focused on local and global point queries.
This includes the retrieval of specific nodes, edges, or routes at a
specific time point, supported in the Historical Graph
Store~\cite{Khurana2016} and in Koloniari et al.~\cite{Koloniari2012}.
Georte et al. support anomaly detection through a subgraph query to
locate specific nodes that have anomalous readings~\cite{George2009}.
Khurana and Deshpande provide a snapshot retrieval operation for a
specific time point~\cite{Khurana2013}, as does the G*
system~\cite{Labouseur2015}.  The main focus in all these approaches
is the physical layout of the data and the access methods for fastest
retrieval.

\eat{Note that any closed algebra on evolving graphs cannot support these
operators directly because the result is inherently nontemporal.
However, the spirit of the queries can be supported through, e.g.,
subgraphs with a temporal predicate.}

Three systems in the literature focus on systematic support of
evolving graphs, all of them non-compositional.  Miao et
al.~\cite{Miao2015} developed ImmortalGraph, a proprietary in-memory
execution engine for temporal graph analytics.  ImmortalGraph does not
provide a query language, focusing primarily on efficient physical
data layout.  The G* system~\cite{Labouseur2015} manages graphs that
correspond to periodic snapshots, with the focus on efficient data
layout.  Time is not an intrinsic part of the system, as it is in
\tga, and thus temporal queries with time predicates like node
creation are not supported.  G* provides graph operators such as
retrieving vertices and their edges from disk and non-graph operators
like aggregate, union, projection, and join.  Finally, the Historical
Graph Store (HGS) system~\cite{Khurana2016} is an evolving graph query
system based on Spark.  It uses the property graph model and supports
retrieval tasks along time and entity dimensions through Java and
Python API.  It provides a range of operators such as selection,
timeslice, nodecompute (similar to map but also with no temporal
information), as well as various evolution-centered operators.  HGS
does not provide formal semantics for any of the operations it
supports and the main focus is on efficient on-disk representation for
retrieval.

\tga is strictly more expressive than any of the three systems and is
the only evolving graph algebra to provide node and edge creation as
well as suport for temporal predicates.
