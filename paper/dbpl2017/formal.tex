\section{Formal \tga properties}
\label{sec:formal}

Several properties of temporal languages have been studied: temporal
groupedness, temporal semi-completeness, and temporal
completeness~\cite{Bohlen1995}.  We show that the \tg model is
temporally ungrouped but strongly equivalent to the canonical
temporally grouped model.  We also show that \tga is snapshot
reducible with respect to a generalized nontemporal graph query
language described in~\cite{Wood2012}.  Additionally, we show that
\tga is not temporally semi-complete or temporally complete.  We
review each of these points.

\subsection{Temporal Groupedness}

Clifford et al. define two basic strategies for adding temporal
information into the relational model: temporally ungrouped (tuple
timestamping or first-normal-form) and temporally grouped (attribute
timestamping or non-first-normal-form)~\cite{Clifford1994}.  Temporal
relations in \tra, based on the TSQL2 model, are temporally
ungrouped~\cite{Bohlen1995}, since each tuple is associated with its
period of validity.  In such a model, a change to one attribute
results in a new tuple.  In a temporally grouped model related facts
are grouped and their attributes are associated with their individual
periods of validity with the use of a function.  Formally:

\begin{definition}[Canonical temporally ungrouped relation model]
[adapted from~\cite{Clifford1994}, pp. 69-70]  Let $U_D =
\{D_1,\ldots,D_{n_d}\}$ be a set of non-empty value domains, and
$\mathbf{D} = \bigcup^{N_d}_{l=1}D_l$ be the set of all values. Let
$\Omega^T = \{t_0,\ldots,t_i,\ldots\}$ be a non-empty, at most countably
infinite, set of times with total order.  Let $U_A =
\{A_1,\ldots,A_n\}$ be a set of nontemporal attributes, and $T$ a
distinguished time attribute not in $U_A$.

A temporally ungrouped (TU) relation schema $R_{TU}$ is a 3-tuple
$R_{TU} = <\mathbf{A},\mathbf{K},\mathbf{DOM}>$, where:

\begin{itemize}[noitemsep,itemindent=\dimexpr\labelwidth+\labelsep\relax,leftmargin=5pt]
\item $\mathbf{A} \cup \{T\} (\mathbf{A} \subseteq U_A)$ is the set of attributes of the schema.
\item $\mathbf{K} \cup \{T\} (\mathbf{K} \subseteq \mathbf{A})$ is the key of the schema, i.e., $\mathbf{K} \cup \{T\} \to \mathbf{A}$.
\item $\mathbf{DOM}: \mathbf{A} \cup \{T\} \to U_D \cup \{\Omega^T\}$ is a function that assigns domains to attributes in $\mathbf{A}$ and $T$ to $\Omega^T$.
\end{itemize}

A TU database schema $DB_{TU}$ is a finite set of TU relation schemas.
A tuple $rt$ on schema $R_{TU}$ is a function that associates a value
for each attribute $A_i \in \mathbf{A}$ in domain $\mathbf{DOM}(A_i)$
and a value in $T$ to $\Omega^T$.  A TU relation is a finite set of TU
tuples satisfying the key constraint.
\end{definition}

\eat{Observe that the temporal relational schema defined in
Section~\ref{sec:model:temporal} is isomorphic to a temporally
ungrouped relation structure, by using intervals instead of time
points.  This is formally shown in~\cite{Bohlen1995}.}

A canonical temporally grouped relation maintains the notion of an
object changing over time.  As we will show that the \tg model is
isomorphic to TU, We do not include the formal definition of the
canonically grouped relation model.  Refer to~\cite{Clifford1994} for
the definition and additional discussion.

%Formally:
\eat{
\begin{definition}[Canonical temporally grouped relation model]
[adapted from~\cite{Clifford1994}, pp. 70-71] Let $U_D$, $\mathbf{D}$,
$\Omega^T$, and $U_A$ be defined as for the canonical temporally
ungrouped relation structure above.  Any subset of $\mathbf{L}
\subseteq \Omega^T$ is called a {\em lifespan}.
}
\eat{
A temporally grouped (TG) relation schema $R_{TG}$ is a 3-tuple
$R_{TG} = <\mathbf{A},\mathbf{K},\mathbf{DOM}>$, where:
}
\eat{
\begin{itemize}
\item $\mathbf{A} \subseteq U_A$ is the set of attributes of the schema.
\item $\mathbf{K} \subseteq \mathbf{A}$ is the key of the schema, i.e., $\mathbf{K} \to \mathbf{A}$.
\item $\mathbf{DOM}: \mathbf{A} \to U_D \cup \{\Omega^T\}$ is a
  function that assigns to each attribute a value domain and the
  corresponding temporal domain.
\end{itemize}
}
\eat{
A TG database schema $DB_{TG}$ is a finite set of TG relation schemas.
A tuple $rt$ on schema $R_{TG}$ is a function that associates with
each attribute $A_i \in \mathbf{A}$ a temporal function from the tuple
lifespan to the domain assigned to the attribute $\mathbf{DOM}(A_i)$.
A TG relation is a finite set of TG tuples such that no two tuples
agree on all keys at any instant in time.
\end{definition}
}

What makes TU relations ungrouped is that there is no mechanism to
identify the tuples that correspond to the same entity over time,
i.e., there is no unique grouped relation for an ungrouped relation.
Without a grouping mechanism the TU model and the TG model are only
{\em weakly} equivalent~\cite{Clifford1994}.

The \tg model is ungrouped by the virtue of being expressed over an
ungrouped relational model of \tra.  However, the \tg model requires
that each node and edge have an id that serves as a key and persists
over time, or, in Clifford terminology, it uses constant keys for a
group identifier~\cite{Clifford1994}.  With this restriction the \tga
model is strongly equivalent to the canonical temporally grouped model.

The reasons that we chose the ungrouped model are two-fold: a) it is
the de-facto standard in the temporal relational database community
after more than two decades of discussion, and b) it is conceptually
easier to express temporal predicates over the ungrouped model.

\subsection{Temporal Completeness}
\label{sec:formal:reducible}

B{\"{o}}hlen, et al. define two kinds of upwards
  compatability with respect to a nontemporal model: temporal
  semi-completeness and temporal completeness~\cite{Bohlen1995}.  To
  define both we need to recollect the notion of snapshot reducibility.

Snapshot reducibility states that for every nontemporal query $q$ in
language $L$, there must exist a corresponding temporal query $q^t$ in
the temporal language $L^t$ that generalizes $q$~\cite{Dignos2012}.
Note that this definition does not pose any restrictions on the syntax
of the temporal query, so it may be expressed quite differently than
the nontemporal one.  It also does not restrict the temporal language
from having other operators with no nontemporal counterparts.

We can show that \tga is snapshot reducible with respect to
  a particular graph query language.

%For a point-based model, it is customary to interrogate two
%properties --- snapshot reducibility (S-reducibility) and extended
%snapshot reducibility (extended S-reducibility).
%
%S-reducibility states that for every query $q$ in $L$, there must
%exist a syntactically similar query $q^t$ in $L^t$ that generalizes
%$q$ \revision{(Def.~\ref{def:reducibility})}.  Specifically, the
%following relationship should hold when $q^t$ is evaluated over a
%temporal database $D^t$ (recall that $\tau$ is the temporal slice
%operator): $q(\tau_c(D^t)) = \tau_c(q^t(D^t))$, for all time points
%$c$.  Extended S-reducibility requires that $L^t$ provide an ability
%to make explicit references to timestamps alongside non-temporal
%predicates.

\begin{theorem}
\label{theo:reduce}
\tga satisfies the snapshot reducibility properties below with respect
to the generalized graph query language based on the survey by
Wood~\cite{Wood2012}.  $\textsf{snap}_p$ is an operator over \tgs that
computes a graph snapshot at point $p$.

\begin{enumerate}[itemindent=\dimexpr\labelwidth+\labelsep\relax,leftmargin=7pt]
\item $\forall p \in \Omega^T (\textsf{snap}_p(\vmap{f_v,\ttt}) \Leftrightarrow \textsf{map}_v(f_v,\textsf{snap}_p(\ttt)))$

\item $\forall p \in \Omega^T (\textsf{snap}_p(\emap{f_e,\ttt}) \Leftrightarrow \textsf{map}_e(f_e,\textsf{snap}_p(\ttt)))$

\item $\forall p \in \Omega^T (\textsf{snap}_p(\sub{P}{\ttt}) \Leftrightarrow \textsf{subgraph}(P,\textsf{snap}_p(\ttt)))$

\item $\forall p \in \Omega^T (\textsf{snap}_p(\textsf{agg}^T(P,\ttt)) \Leftrightarrow \textsf{agg}(P,\textsf{snap}_p(\ttt)))$

\item $\forall p \in \Omega^T (\textsf{snap}_p(\textsf{node}^T_a(P,\ttt)) \Leftrightarrow \textsf{node}(P,\textsf{snap}_p(\ttt)))$

%\item $\forall p \in \Omega^T (\textsf{snap}_p(\textsf{edge}^T_{P=f_e(\ttt_1.v,\ttt_2.v),f_{v1}(k_1)=f_{v2}(k2)=\ldots=f_{vn}(k_n)=\textsf{any}}(\ttt_1,\ttt_2)) \Leftrightarrow \textsf{snap}_p(\ttt_1) + \textsf{snap}_p(\ttt_2))$ \\($+$ stands for graph join)

%\item $\forall p \in \Omega^T (\textsf{snap}_p(\sub{P_1}{\textsf{edge}^T_{P_2,f_{v1}(k_1)=\ldots=f_{vn}(k_n)=\textsf{any}}(\ttt_1,\ttt_2)}) \Leftrightarrow \textsf{snap}_p(\ttt_1) \odot_{\sigma1,\sigma2,g} \textsf{snap}_p(\ttt_2))$
\end{enumerate}

The equivalences hold for arbitrary \tgs.  The only restriction in
this theorem is that any pattern $P$ and mapping function $f_v$/$f_e$
do not refer to the time attribute, in line with snapshot reducibility.
\end{theorem}

The proof is included in Appendix B.

Extended snapshot-reducibility requires that $L^t$ provide an ability
to make explicit references to timestamps alongside non-temporal
predicates.  \tga is extended snapshot-reducible because, for each
operator in \tga that includes patterns or predicates, temporal
predicates are explicitly supported, according to Def.~\ref{def:tngp}.

As noted, snapshot reducibility places no restrictions on the syntax
of the temporal language.  To deal with the syntax, B{\"{o}}hlen, et
al., define a more restrictive type of upward compatability termed {\em
  temporal semi-completeness}~\cite{Bohlen1995} or
S-reducibility~\cite{Bohlen2000}.

\begin{definition}[Temporal semi-completeness]
[\cite{Bohlen1995}, p. 162] Let $M = (DS,L)$ be a nontemporal data
model and $M^T = (DS^t,L^t)$ be a valid-time temporal data model.
Then data model $M^t$ is temporally semi-complete with respect to $M$
iff:

\begin{enumerate}[noitemsep,itemindent=\dimexpr\labelwidth+\labelsep\relax,leftmargin=7pt]
\item For every relation $\mathbf{r}$ in $DS$ there exists a temporal
  relation $\mathbf{r^t}$ in $DS^T$ such that $\mathbf{r} =
  \tau_t(\mathbf{r^t})$.
\item For every query $q$ in $L$, there exists a query $q^t$ in $L^t$
  that is snapshot reducible with respect to $q$.
\item There exist two text strings $S_1$ and $S_2$ such that for all
  pairs of queries $(q,q^t)$, where $q^t$ is snapshot reducible to
  $q$, query $q^t$ is syntactically identical to $S_1qS_2$.
\end{enumerate}
\end{definition}

The intent of temporal semi-completeness is to provide a kind of
upward compatability that simplifies the transition of nontemporal
language users to the temporal variant.  \eat{For example, TSQL2 provides a
\insql{VALID} keyword that indicates that the query is over the
valid-time temporal semantics.  Interestingly, it has been shown that
TSQL2 is not temporally semi-complete with respect to SQL-92 because
of a) its restriction to duplicate free set semantics, and b) lack of
snapshot reducible counterparts for nested queries~\cite{Bohlen1995}.}

The \tg model meets condition 1, since every snapshot graph
  can be modeled as a \tg with a unit interval as its timestamp.  The
  use of duplicate free set-based semantics is not an issue because
  graph snapshots do not allow duplicates either -- every node and
  edge has an identity.  Condition 2 is also satisfied, as we already
  showed that for every graph operator there is a corresponding \tga
  operator that is snapshot-reducible.

Since \tga does not specify a syntax, requirement 3 cannot
  be satisfied.  The definitions in Section~\ref{sec:algebra} specify
  the semantics of each operator, but do not dictate any specific way
  the operator must be expressed by the user.  For instance, we do not
  specify how the patterns are specified.  Thus \tga cannot be
  considered temporally semi-complete with respect to any graph query
  language.

A further notion of upward compatability is {\em temporal
  completeness}, which requires semi-completeness, as well as an
ability to override snapshot reducibility and to refer to original
intervals as specified by the user~\cite{Bohlen1995}.  The last
condition is termed {\em change preservation}~\cite{Dignos2012} and is
a property of sequenced semantics.

\eat{
\begin{definition}[Temporal completeness]
[\cite{Bohlen1995}, p. 166]  Let $M = (DS,L)$ be a nontemporal data
model and $M^T = (DS^t,L^t)$ be a valid-time temporal data model.
Then data model $M^t$ is temporally complete with respect to $M$
iff:
}
\eat{
\begin{itemize}[noitemsep,itemindent=\dimexpr\labelwidth+\labelsep\relax,leftmargin=5pt]
\item $M^t$ is temporally semi-complete with respect to $M$.
\item It is possible to override snapshot reducibility for every
  snapshot reducible query $q^t$ in $L^t$ by some syntactic means such
  as dropping the syntactic extensions that enforce it.
\item Syntactic reducibility can be applied to subqueries.
\item Allen's interval operators or their equivalents can be used in queries.
\item It is possible to refer to both the (a) coalesced interval and (b) original intervals as specified by the user.
\end{itemize}
\end{definition}
}

\eat{Condition 2 is elsewhere termed {\em
  nonrestrictiveness}~\cite{Bohlen2000} and gives the user full
control over the timestamps as regular values if desired. Condition 5
essentially refers to the change preservation property of sequence
semantics~\cite{Dignos2012}, without which the intervals specified by
the user have no special meaning.  Any point semantics coalesces
value-equivalent consecutive and overlapping tuples and does not
preserve user-specified intervals.}

\tga is not temporally complete both because it is not temporally
semi-complete and because it uses point semantics, thus violating the
change preservation property.

%\revision{
%\tga is S-reducible because for each operator in \tga, one of the following hold:}

%\revision{\begin{enumerate}[label=\Alph*]
%\item It is rewritten into a sequence of \tra operators, each of which
%  is S-reducible.
%\item It uses temporal navigational graph patterns (TNGPs).  The
%  semantics of the TNGP, when no temporal predicates are present, per
%  Def.~\ref{def:tngp}, is the same as the semantics of the
%  Navigational Graph Patterns (Def~\ref{def:ngp}), i.e., the patterns
%  are semantically applied to each instance of time.
%\end{enumerate}}

%\revision{\tga is extended S-reducible because for each operator in \tga, it
%allows the user to refer to the timestamp of nodes and edges without
%modifying them directly.
%}

\eat{, either it is rewritten into \tra, which is S-reducible w.r.t. relational algebra, or \tga is s-reducible and extended s-reducible because, as we showed in
Section~\ref{sec:algebra}, every \tga operation can be rewritten into
\tra, which is S-reducible and extended S-reducible w.r.t. relational
algebra.  For those operators that are defined using graph patterns,
we can show the following:}

\eat{\begin{enumerate}
\item That an operation with a temporal navigational graph pattern
  (TNGP) is S-reducible when any regular path expressions in the
  pattern are constrained by a temporal predicate \insql{overlaps}
  such that all edges forming a path must coexist.  In this case the
  TNGP is equivalent to a regular navigational pattern in graph
  algebras (Def.~\ref{def:ngp}) and can be semantically applied to
  every point in time.
\item That an operation with a temporal navigational graph pattern is
  extended S-reducible because it allows the user to refer to the
  timestamp of nodes and edges without modifying them, per
  Def.~\ref{def:tngp}.
\end{enumerate}
}

\eat{For those operators that are defined using graph patterns,
e.g., vertex-subgraph (Def.~\ref{def:subv}), we can convert from one
representation to another in polynomial time, as proven in
Theorem~\ref{tgr_tg}.}

\eat{\vera{Not every operator is currently defined through \tra.  However,
  every one that uses patterns can be rewritten to use a conjunctive
  query.}}

\eat{
\julia{Is this a correct statement?} We showed above that \ql algebra
is TRA-\edgec and TRA-\vertexc.  Further, we showed that every
operation on \ql algebra is expressible by a sequence of \tra
queries. Since \tra is known to be S-reducible and extended S-reducible
with respect to relational algebra~\cite{}, then these properties also
hold over the queries that produce vertices and edges in \ql.}

% Make a connection to sequenced semantics - we don't support change
% preservation.

\eat{
\section{Operation equivalences}
\label{sec:equivalences}
}

