\section{Formal \tga properties}
\label{sec:formal}

Several properties of temporal languages have been studied: temporal
groupedness, temporal semi-completeness, and temporal
completeness~\cite{Bohlen1995}.  We show that the \tg model is
temporally ungrouped but strongly equivalent to the canonical
temporally grouped model.  We also show that \tga is is snapshot
reducible with respect to a generalized nontemporal graph query
language described in~\cite{Wood2012}.  Additionally, we show that
\tga is not temporally semi-complete or temporally complete.  We
review each of these points in turn.  Finally, we study the expressive
power of a fragment of \tga.

\subsection{Temporal Groupedness}

Clifford et al. define two basic strategies for adding temporal
information into the relational model: temporally ungrouped (tuple
timestamping or first-normal-form) and temporally grouped (attribute
timestamping or non-first-normal-form)~\cite{Clifford1994}.  Temporal
relations in \tra, based on the TSQL2 model, are temporally
ungrouped~\cite{Bohlen1995}, since each tuple is associated with its
period of validity.  In such a model, a change to one attribute
results in a new tuple.  In a temporally grouped model related facts
are grouped and their attributes are associated with their individual
periods of validity with the use of a function.

Formally:

\begin{definition}[Canonical temporally ungrouped relation model]
[adapted from~\cite{Clifford1994}, pp. 69-70]  Let $U_D =
\{D_1,\ldots,D_{n_d}\}$ be a set of non-empty value domains, and
$\mathbf{D} = \bigcup^{N_d}_{l=1}D_l$ be the set of all values. Let
$\Omega^T = \{t_0,\ldots,t_i,\ldots\}$ be a non-empty, at most countably
infinite, set of times with total order.  Let $U_A =
\{A_1,\ldots,A_n\}$ be a set of nontemporal attributes, and $T$ a
distinguished time attribute not in $U_A$.

A temporally ungrouped (TU) relation schema $R_{TU}$ is a 3-tuple
$R_{TU} = <\mathbf{A},\mathbf{K},\mathbf{DOM}>$, where:

\begin{itemize}[noitemsep,itemindent=\dimexpr\labelwidth+\labelsep\relax,leftmargin=5pt]
\item $\mathbf{A} \cup \{T\} (\mathbf{A} \subseteq U_A)$ is the set of attributes of the schema.
\item $\mathbf{K} \cup \{T\} (\mathbf{K} \subseteq \mathbf{A})$ is the key of the schema, i.e., $\mathbf{K} \cup \{T\} \to \mathbf{A}$.
\item $\mathbf{DOM}: \mathbf{A} \cup \{T\} \to U_D \cup \{\Omega^T\}$ is a function that assigns domains to attributes in $\mathbf{A}$ and $T$ to $\Omega^T$.
\end{itemize}

A TU database schema $DB_{TU}$ is a finite set of TU relation schemas.
A tuple $rt$ on schema $R_{TU}$ is a function that associates a value
for each attribute $A_i \in \mathbf{A}$ in domain $\mathbf{DOM}(A_i)$
and a value in $T$ to $\Omega^T$.  A TU relation is a finite set of TU
tuples satisfying the key constraint.
\end{definition}

\eat{Observe that the temporal relational schema defined in
Section~\ref{sec:model:temporal} is isomorphic to a temporally
ungrouped relation structure, by using intervals instead of time
points.  This is formally shown in~\cite{Bohlen1995}.}

A canonical temporally grouped relation maintains the notion of an
object changing over time.  We do not include the definition here, refer to~\cite{Clifford1994}.

%Formally:
\eat{
\begin{definition}[Canonical temporally grouped relation model]
[adapted from~\cite{Clifford1994}, pp. 70-71] Let $U_D$, $\mathbf{D}$,
$\Omega^T$, and $U_A$ be defined as for the canonical temporally
ungrouped relation structure above.  Any subset of $\mathbf{L}
\subseteq \Omega^T$ is called a {\em lifespan}.
}
\eat{
A temporally grouped (TG) relation schema $R_{TG}$ is a 3-tuple
$R_{TG} = <\mathbf{A},\mathbf{K},\mathbf{DOM}>$, where:
}
\eat{
\begin{itemize}
\item $\mathbf{A} \subseteq U_A$ is the set of attributes of the schema.
\item $\mathbf{K} \subseteq \mathbf{A}$ is the key of the schema, i.e., $\mathbf{K} \to \mathbf{A}$.
\item $\mathbf{DOM}: \mathbf{A} \to U_D \cup \{\Omega^T\}$ is a
  function that assigns to each attribute a value domain and the
  corresponding temporal domain.
\end{itemize}
}
\eat{
A TG database schema $DB_{TG}$ is a finite set of TG relation schemas.
A tuple $rt$ on schema $R_{TG}$ is a function that associates with
each attribute $A_i \in \mathbf{A}$ a temporal function from the tuple
lifespan to the domain assigned to the attribute $\mathbf{DOM}(A_i)$.
A TG relation is a finite set of TG tuples such that no two tuples
agree on all keys at any instant in time.
\end{definition}
}

What makes TU relations ungrouped is that there is no mechanism to
identify the tuples that correspond to the same entity over time,
i.e., there is no unique grouped relation for an ungrouped relation.
Without a grouping mechanism the TU model and the TG model are only
{\em weakly} equivalent~\cite{Clifford1994}.

The \tg model is ungrouped by the virtue of being expressed over an
ungrouped relational model of \tra.  However, the \tg model requires
that each node and edge have an id that serves as a key and persists
over time, or, in Clifford terminology, it uses constant keys for a
group identifier~\cite{Clifford1994}.  With this restriction the \tga
model is strongly equivalent to the canonical temporally grouped model.

The reasons that we chose the ungrouped model are two-fold: a) it is
the de-facto standard in the temporal relational database community
after more than two decades of discussion, and b) it is easier to
express temporal predicates over the ungrouped model.

\subsection{Temporal Completeness}
\label{sec:formal:reducible}

B{\"{o}}hlen, et al. define two kinds of upwards
  compatability with respect to a nontemporal model: temporal
  semi-completeness and temporal completeness~\cite{Bohlen1995}.  To
  define both we need to recollect the notion of snapshot reducibility.

Snapshot reducibility states that for every nontemporal query $q$ in
language $L$, there must exist a corresponding temporal query $q^t$ in
the temporal language $L^t$ that generalizes $q$~\cite{Dignos2012}.
Note that this definition does not pose any restrictions on the syntax
of the temporal query, so it may be expressed quite differently than
the nontemporal one.  It also does not restrict the temporal language
from having other operators with no nontemporal counterparts.

We can show that \tga is snapshot reducible with respect to
  a particular graph query language.

%For a point-based model, it is customary to interrogate two
%properties --- snapshot reducibility (S-reducibility) and extended
%snapshot reducibility (extended S-reducibility).
%
%S-reducibility states that for every query $q$ in $L$, there must
%exist a syntactically similar query $q^t$ in $L^t$ that generalizes
%$q$ \revision{(Def.~\ref{def:reducibility})}.  Specifically, the
%following relationship should hold when $q^t$ is evaluated over a
%temporal database $D^t$ (recall that $\tau$ is the temporal slice
%operator): $q(\tau_c(D^t)) = \tau_c(q^t(D^t))$, for all time points
%$c$.  Extended S-reducibility requires that $L^t$ provide an ability
%to make explicit references to timestamps alongside non-temporal
%predicates.

\begin{theorem}
\label{theo:reduce}
\tga satisfies the snapshot reducibility properties below with respect
to the generalized graph query language based on the survey by
Wood~\cite{Wood2012}.  $\textsf{snap}_p$ is an operator over \tgs that
computes a graph snapshot at point $p$.

\begin{enumerate}[itemindent=\dimexpr\labelwidth+\labelsep\relax,leftmargin=5pt]
\item $\forall p \in \Omega^T (\textsf{snap}_p(\vmap{f_v,\ttt}) \Leftrightarrow \textsf{map}_v(f_v,\textsf{snap}_p(\ttt)))$

\item $\forall p \in \Omega^T (\textsf{snap}_p(\emap{f_e,\ttt}) \Leftrightarrow \textsf{map}_e(f_e,\textsf{snap}_p(\ttt)))$

\item $\forall p \in \Omega^T (\textsf{snap}_p(\sub{P}{\ttt}) \Leftrightarrow \textsf{subgraph}(P,\textsf{snap}_p(\ttt)))$

\item $\forall p \in \Omega^T (\textsf{snap}_p(\textsf{agg}^T(P,\ttt)) \Leftrightarrow \textsf{agg}(P,\textsf{snap}_p(\ttt)))$

\item $\forall p \in \Omega^T (\textsf{snap}_p(\textsf{node}^T_a(P,\ttt)) \Leftrightarrow \textsf{node}(P,\textsf{snap}_p(\ttt)))$

%\item $\forall p \in \Omega^T (\textsf{snap}_p(\textsf{edge}^T_{P=f_e(\ttt_1.v,\ttt_2.v),f_{v1}(k_1)=f_{v2}(k2)=\ldots=f_{vn}(k_n)=\textsf{any}}(\ttt_1,\ttt_2)) \Leftrightarrow \textsf{snap}_p(\ttt_1) + \textsf{snap}_p(\ttt_2))$ \\($+$ stands for graph join)

%\item $\forall p \in \Omega^T (\textsf{snap}_p(\sub{P_1}{\textsf{edge}^T_{P_2,f_{v1}(k_1)=\ldots=f_{vn}(k_n)=\textsf{any}}(\ttt_1,\ttt_2)}) \Leftrightarrow \textsf{snap}_p(\ttt_1) \odot_{\sigma1,\sigma2,g} \textsf{snap}_p(\ttt_2))$
\end{enumerate}

The equivalences hold for arbitrary \tgs, except equivalence 6, graph
join, which is defined specifically for disjoint graphs.  The only
restriction in this theorem is that any pattern $P$ and mapping
function $f_v$/$f_e$ do not refer to the time attribute.
\end{theorem}

The proof is included in Appendix B.

As noted, snapshot reducibility places no restrictions on the syntax
of the temporal language.  To deal with the syntax, B{\"{o}}hlen, et
al., define a more restrictive type of upward compatability termed {\em
  temporal semi-completeness}~\cite{Bohlen1995} or
S-reducibility~\cite{Bohlen2000}.

\begin{definition}[Temporal semi-completeness]
[\cite{Bohlen1995}, p. 162] Let $M = (DS,L)$ be a nontemporal data
model and $M^T = (DS^t,L^t)$ be a valid-time temporal data model.
Then data model $M^t$ is temporally semi-complete with respect to $M$
iff:

\begin{itemize}[noitemsep,itemindent=\dimexpr\labelwidth+\labelsep\relax,leftmargin=5pt]
\item For every relation $\mathbf{r}$ in $DS$ there exists a temporal
  relation $\mathbf{r^t}$ in $DS^T$ such that $\mathbf{r} =
  \tau_t(\mathbf{r^t})$.
\item For every query $q$ in $L$, there exists a query $q^t$ in $L^t$
  that is snapshot reducible with respect to $q$.
\item There exist two text strings $S_1$ and $S_2$ such that for all
  pairs of queries $(q,q^t)$, where $q^t$ is snapshot reducible to
  $q$, query $q^t$ is syntactically identical to $S_1qS_2$.
\end{itemize}
\end{definition}

The intent of temporal semi-completeness is to provide a kind of
upward compatability that simplifies the transition of nontemporal
language users to the temporal variant.  \eat{For example, TSQL2 provides a
\insql{VALID} keyword that indicates that the query is over the
valid-time temporal semantics.  Interestingly, it has been shown that
TSQL2 is not temporally semi-complete with respect to SQL-92 because
of a) its restriction to duplicate free set semantics, and b) lack of
snapshot reducible counterparts for nested queries~\cite{Bohlen1995}.}

The \tg model meets condition 1, since every snapshot graph
  can be modeled as a \tg with a unit interval as its timestamp.  The
  use of duplicate free set-based semantics is not an issue because
  graph snapshots do not allow duplicates either -- every node and
  edge has an identity.  Condition 2 is also satisfied, as we already
  showed that for every graph operator there is a corresponding \tga
  operator that is snapshot-reducible.

Since \tga does not specify a syntax, requirement 3 cannot
  be satisfied.  The definitions in Section~\ref{sec:algebra} specify
  the semantics of each operator, but do not dictate any specific way
  the operator must be expressed by the user.  For instance, we do not
  specify how the patterns are specified.  Thus \tga cannot be
  considered temporally semi-complete with respect to any graph query
  language.

A further notion of upward compatability is {\em temporal
  completeness}.

\begin{definition}[Temporal completeness]
[\cite{Bohlen1995}, p. 166]  Let $M = (DS,L)$ be a nontemporal data
model and $M^T = (DS^t,L^t)$ be a valid-time temporal data model.
Then data model $M^t$ is temporally complete with respect to $M$
iff:

\begin{itemize}[noitemsep,itemindent=\dimexpr\labelwidth+\labelsep\relax,leftmargin=5pt]
\item $M^t$ is temporally semi-complete with respect to $M$.
\item It is possible to override snapshot reducibility for every
  snapshot reducible query $q^t$ in $L^t$ by some syntactic means such
  as dropping the syntactic extensions that enforce it.
\item Syntactic reducibility can be applied to subqueries.
\item Allen's interval operators or their equivalents can be used in queries.
\item It is possible to refer to both the (a) coalesced interval and (b) original intervals as specified by the user.
\end{itemize}
\end{definition}

Condition 2 is elsewhere termed {\em
  nonrestrictiveness}~\cite{Bohlen2000} and gives the user full
control over the timestamps as regular values if desired. Condition 5
essentially refers to the change preservation property of sequence
semantics~\cite{Dignos2012}, without which the intervals specified by
the user have no special meaning.  Any point semantics coalesces
value-equivalent consecutive and overlapping tuples and does not
preserve user-specified intervals.

\tga is not temporally complete both because it is not temporally
semi-complete and because it uses point semantics, thus violating the
final condition.

%\revision{
%\tga is S-reducible because for each operator in \tga, one of the following hold:}

%\revision{\begin{enumerate}[label=\Alph*]
%\item It is rewritten into a sequence of \tra operators, each of which
%  is S-reducible.
%\item It uses temporal navigational graph patterns (TNGPs).  The
%  semantics of the TNGP, when no temporal predicates are present, per
%  Def.~\ref{def:tngp}, is the same as the semantics of the
%  Navigational Graph Patterns (Def~\ref{def:ngp}), i.e., the patterns
%  are semantically applied to each instance of time.
%\end{enumerate}}

%\revision{\tga is extended S-reducible because for each operator in \tga, it
%allows the user to refer to the timestamp of nodes and edges without
%modifying them directly.
%}

\eat{, either it is rewritten into \tra, which is S-reducible w.r.t. relational algebra, or \tga is s-reducible and extended s-reducible because, as we showed in
Section~\ref{sec:algebra}, every \tga operation can be rewritten into
\tra, which is S-reducible and extended S-reducible w.r.t. relational
algebra.  For those operators that are defined using graph patterns,
we can show the following:}

\eat{\begin{enumerate}
\item That an operation with a temporal navigational graph pattern
  (TNGP) is S-reducible when any regular path expressions in the
  pattern are constrained by a temporal predicate \insql{overlaps}
  such that all edges forming a path must coexist.  In this case the
  TNGP is equivalent to a regular navigational pattern in graph
  algebras (Def.~\ref{def:ngp}) and can be semantically applied to
  every point in time.
\item That an operation with a temporal navigational graph pattern is
  extended S-reducible because it allows the user to refer to the
  timestamp of nodes and edges without modifying them, per
  Def.~\ref{def:tngp}.
\end{enumerate}
}

\eat{For those operators that are defined using graph patterns,
e.g., vertex-subgraph (Def.~\ref{def:subv}), we can convert from one
representation to another in polynomial time, as proven in
Theorem~\ref{tgr_tg}.}

\eat{\vera{Not every operator is currently defined through \tra.  However,
  every one that uses patterns can be rewritten to use a conjunctive
  query.}}

\eat{
\julia{Is this a correct statement?} We showed above that \ql algebra
is TRA-\edgec and TRA-\vertexc.  Further, we showed that every
operation on \ql algebra is expressible by a sequence of \tra
queries. Since \tra is known to be S-reducible and extended S-reducible
with respect to relational algebra~\cite{}, then these properties also
hold over the queries that produce vertices and edges in \ql.}

% Make a connection to sequenced semantics - we don't support change
% preservation.

\eat{
\section{Operation equivalences}
\label{sec:equivalences}
}

\subsection{Expressive Power}
\label{sec:epower}

In this section we study expressiveness of the \tg model, which
consists of the \tg data structure (Definition~\ref{def:tg2}) and of
\tga, an algebra for querying the data structure
(Section~\ref{sec:algebra}). We stress that ours is a valid-time data
model that does not provide transaction-time and bi-temporal support.

{\bf Important note:} We restrict our attention to a subset of \tga
operations, excluding recursive queries.  That is, every operation
where Temporal Navigational Graph Patterns (Def.~\ref{def:tngp}) are
applied is restricted to Basic Graph
Patterns~\cite{DBLP:journals/corr/AnglesABHRV16} with temporal
predicates.  A Basic Graph Pattern is equivalent to a regular
conjunctive query without projection~\cite{Abiteboul1995}.  We also
restrict the property values to atomic types for the purposes of this
discussion.

We start by proposing two natural notions of completeness for a
temporal graph query language.

\begin{definition}
  Let $L^t$ be a temporal relational language and $\tve$ --- a
  relational representation of a temporal graph.  An \edgeq $q^t_e$ in
  $L$ takes a graph $\tve (\tv, \te)$ as input, and
  outputs another graph $\tve'$ on the vertices of $\tve$ such that
  the edges of $\tve'$ are defined by $q^t_e$.  A language is
  $L^t$-\edgec if it can express each $q^t_e$ in $L^t$.
  \label{def:edgecomplete}
\end{definition}

Note that the query $q^t_e$ is not restricted to act on \te alone, and
may refer to the other constituent relation of \tve, namely, \tv.

\begin{definition}
  Let $L^t$ be a temporal relational language, and let $\tve$ be a
  relational representation of a temporal graph.  A \vertexq $q^t_v$
  in $L^t$ takes a graph $\tve (\tv, \te)$ as input, and
  outputs another graph $\tve'$ such that the vertices of $\tve'$ are
  defined by $q^t_v$. A language is $L^t$-\vertexc if it can express
  each $q^t_v$ in $L^t$.
\label{def:vertexcomplete}
\end{definition}

We now refer to definitions~\ref{def:edgecomplete}
and~\ref{def:vertexcomplete} and show that \tga is \edgec and
\vertexc, with respect to the valid-time fragment of temporal
relational algebra (\tra).  \tra is an algebra that corresponds to
temporal relational calculus~\cite{DBLP:reference/db/ChomickiT09b}, a
first-order logic that extends relational calculus, supporting
variables and quantifiers over both the data domain and time domain.

\begin{theorem}
\tga is TRA-\edgec.
\label{th:edgecomplete}
\end{theorem}

\begin{proof}
%  \mathsf{(sketch)}
  The result of every conjunctive edge-query over the vertices of \ttt
  can be expressed by $\sigma_{c} (\tv \times^T \tv)$.  Queries of
  this kind can be expressed by the edge creation operator of \tga
  (Def.~\ref{def:edgecr}), invoked as:\\
  $\insql{edge}^T(q=\sigma_{c} (\ttt_1.\tv \times^T \ttt_2.\tv),\ttt_1
  = \ttt,\ttt_2=\ttt)$\end{proof}

\begin{theorem}
\tga is TRA-\vertexc.
\label{th:vertexcomplete}
\end{theorem}

\begin{proof}
%  \mathsf{(sketch)}
  Every \tra vertex-query can be expressed in \tga
  by a sequence of vertex-subgraph $q^T_v(\tve)$
  (Def.~\ref{def:subv}) and attribute-based node creation
  $\insql{node}^T_a$ (Def.~\ref{def:nodecra}).
  Attribute-based node creation supports Skolem functions, and is
  necessary to handle queries that introduce vertex identifiers.  
\end{proof}


