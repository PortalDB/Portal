\section{Related Work}
\label{sec:related}

{\bf Querying and analytics.} \ql is the first proposed declarative
query language for evolving graphs.  There has been much recent work
on analytics for evolving graphs,
see~\cite{DBLP:journals/csur/AggarwalS14} for a survey. This line of
work is synergistic with ours, since our aim is to provide systematic
support for scalable querying and analysis of evolving graphs.

Several researchers have proposed individual queries, or classes of
queries, for evolving graphs, but without a unifying syntax or general
framework.  Kan et al.~\cite{Kan2009} propose a query model for
discovering subgraphs that match a specific spatio-temporal pattern.
Chan et al.~\cite{Chan2008} query evolving graphs for patterns
represented by waveforms.  Semertzidis et al.~\cite{Semertzidis2015}
focus on historical reachability queries.

Our work shares motivation with Miao et
al.~\cite{DBLP:journals/tos/MiaoHLWYZPCC15}, who developed an
in-memory execution engine for temporal graph analytics called
ImmortalGraph.  Unlike Miao et al., who focus on in-memory layout and
locality-aware scheduling mechanisms, we work in a distributed
processing environment.  A further difference is that our work is in
scope of Apache Spark, a widely-used open source platform, while
ImmortalGraph is a proprietary stand-alone prototype.

\eat{Our work differs from query processing on dynamic graphs
(e.g.,~\cite{Mondal2012}), where the history of changes is not
important, and from mining evolving graph streams
(e.g.,~\cite{Liu2010}), where the focus is on discovering significant
changes.}

{\bf Distributed frameworks.}  We build upon
GraphX~\cite{DBLP:conf/osdi/GonzalezXDCFS14}, which provides an API
for working with regular graphs (snapshots) in Apache Spark, but
without the time dimension.  To improve performance, we modified the
GraphX graph loading code, enabling concurrent distributed multi-file
loading with a tuned number of partitions.
%
\eat{Distributed graph computation requires balanced graph partitioning,
dependent on the nature of the operation being applied to the graph.
There are two basic types of graph partitioning strategies.
  Edge-cut distributes vertices across the available machines and
  replicates the edges as necessary, while vertex-cut does the
  opposite.  Based on extensive theoretical and experimental
  studies~\cite{Gonzalez2012}, GraphX chose the vertex-cut approach.} 
We use built-in GraphX partitioning and develop additional vertex-cut
strategies that incorporate the temporal dimension.
%
Another relevant framework is SparkSQL~\cite{Xin2013Shark}, which
provides mid-query optimization of distributed execution.\eat{  Mid-query
optimization is in our immediate plans for \ql.  In SparkSQL tables
to be joined can be co-partitioned at creation time.  This is similar
to what our data structures and partition strategies achieve for
\insql{TGroup} and temporal join.}


