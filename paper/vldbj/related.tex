\section{Related Work}
\label{sec:related}

{\bf Evolving graph models.}  Much recent work
represents evolving graphs as sequences of snapshots in a discrete
time domain, and focuses on snapshot retrieval and
analytics~\cite{Khurana2013,Miao2015,Ren2011}.  Our logical model is
semantically equivalent to a sequence of snapshots because in point
semantics snapshots can be obtained with a simple slice over all time
points.  We choose to represent \tgs as a collection of vertices and
edges because the range of operations we support is naturally
expressible over them but not over a sequence of snapshots.  For
example, subgraph with a temporal predicate is impossible to express
over snapshot sequences as each snapshot is nontemporal and
independent of the others.

Most evolving graph models require node identity, and thus edge
identity as well, to persist across time, but vary in the kind of time
model they adopt and what kind of evolution is represented.
See~\cite{Zaki2016} for a recent survey of evolving graph models. Our
model supports fully evolved graphs (both topological and attribute
evolution for both nodes and edges), uses time intervals for time
granularity (but, as noted above, using point semantics), and provides
both graph-centric and entity-centric views.

It is worth noting that while the logical model adopted by many
researchers is that of a snapshot sequence, the representations differ
and in some cases are similar to our \tg model.  Huo and Tsotras
model an evolving graph as a set of nodes and a set of edges where
each entity is interval-stamped~\cite{Huo2014}.  However, nodes have
no attributes in this model and the edge attributes are weights.
Whether this model is coalesced or not is not formally stated, but we
must assume it is uncoalesced.  Similary,
Koloniari~\cite{Koloniari2012}, while not providing a formal model,
represents nodes and edges as having periods of validity.  We
emphasize that the choice of the logical model impacts the
expressiveness of the algebra and advocate our model over the snapshot
sequence from that perspective.

The most general model we found is by Casteigts et
al.~\cite{Casteigts2011} who define a {\em time-varying graph} as
$\mathcal{G} = (V, E, \mathcal{T}, \rho, \zeta)$, where V and E are
defined as in regular labeled graphs, $\mathcal{T}$ is a time span of
the graph from a temporal domain T, $\rho$ is a presence function that
maps edges to time instances where they are present, and $\zeta$ is a
latency function that indicates the time it takes to cross a given
edge starting at some time instant.  The inclusion of the latency
function allows the time-varying graph model to cover not only
evolving graphs as we define them, but also temporal transportation
and communication networks.  The edge labels can be used in place of
ids or attributes with no distinction in the model.  The nodes in this
model do not have labels or attributes, but could be easily added with
no loss of generality.  Similarly, as the authors note, a node
presence function and node latency function can also be added.  Since
our work is concerned with evolving graphs only, we do not include any
notion of latency.

\eat{This approach is in contrast to an interval-based model that we use
and has several limitations.  First, the state of the graph can be
undefined at some time $t$ unless a snapshot is associated with each
possible value in the discrete range $[t_{start}, now)$.  Second, it
  is not compact: every change to an entity (vertex or edge) requires
  a new snapshot.}\eat{ For large graphs, consecutive snapshots have
    degree of similarity approaching 1 (on the scale of 0 of no
    similarity and 1 full similarity).}\eat{ This has motivated work
    on efficient physical representations that are both compact and
    support efficient snapshot-based
    operations~\cite{Khurana2013,Miao2015,Ren2011}.}

\begin{table*}
\caption{Mapping between \tga and other published systems.}
\small
\begin{tabular}{l | C{4.2cm} | C{4.2cm} | C{4.2cm} }
\hline
\multicolumn{1}{l|}{\bfseries Operation} & \multicolumn{1}{c|}{\bfseries ImmortalGraph} & \multicolumn{1}{c|}{\bfseries G*} & \multicolumn{1}{c}{\bfseries HGS} \\ \hline
slice & Vertex and Edge iterators & VertexOperator & timeslice \\ \hline
subgraph & N/A & N/A & selection, non-temporal, attribute-based \\ \hline
map & N/A & ProjectionOperator & nodecompute, non-temporal \\ \hline
aggregation & indirectly through iterative computing interface & N/A & N/A \\ \hline
union & N/A & UnionOperator (relational, not graph) & N/A \\ \hline
intersection & N/A & JoinOperator (relational, not graph) & N/A \\ \hline
difference & N/A & N/A & N/A \\ \hline
attribute node creation & N/A & AggregateOperator (relational, does not create new nodes) & N/A \\ \hline
temporal node creation & N/A & N/A & N/A \\ \hline
edge creation & N/A & N/A & N/A \\ \hline
\label{tab:systems}
\end{tabular}
\end{table*}

{\bf Querying and analytics.} There has been much recent work on
analytics for evolving graphs,
see~\cite{DBLP:journals/csur/AggarwalS14} for a survey. This line of
work is synergistic with ours, since our aim is to provide systematic
support for scalable querying and analysis of evolving graphs.

Several researchers have proposed individual queries, or classes of
queries, for evolving graphs, but without a unifying syntax or general
framework.  The proposed operators can be divided into those that
return temporal or nontemporal result.  Temporal operators include
retrieval of version data for a particular node and
edge~\cite{George2006}, of journeys~\cite{George2009,Casteigts2011},
subgraph by time or attributes~\cite{Huo2014,Khurana2016}, snapshot
analytics~\cite{Miao2015,Labouseur2015,Khurana2016}, and computation
of time-varying versions of whole-graph analytics like maximal
time-connected component~\cite{Ferreira2004} and dynamic graph
centrality~\cite{Lerman2010}.  Non-temporal operators include snapshot
retrieval~\cite{Khurana2013} and retrieval at time
point~\cite{George2009,Khurana2016}.

Our contribution is to propose one unifying closed \tga that covers
the range of the operations in a complete way, with clear semantics,
which many previous works lack.

{\bf Implementations.}  Three systems in the literature focus on
systematic support of evolving graphs, all of them non-compositional.
Miao et al.~\cite{Miao2015} developed ImmortalGraph (formerly
Chronos), a proprietary in-memory execution engine for temporal graph
analytics.  The ImmortalGraph system has no formal model, but
informally an evolving graph is defined as a series of activities on
the graph, such as node additions and deletions.  This is a streaming
or delta approach, which is popular in temporal databases because it
is unambiguous and compact.  ImmortalGraph does not provide a query
language, focusing primarily on efficient physical data layout.  Many
insights about temporal vs. structural locality by~\cite{Miao2015}
hold in our setting.  The batching method for snapshot analytics used
by \og is similar to the one proposed in ImmortalGraph.  However,
ImmortalGraph was developed with the focus on centralized rather than
distributed computation.  The distributed performance discussion
in~\cite{Miao2015} indicates that batching method gains are reduced
due to communication costs even with a very fast InfiniBand network
and this corresponds to our findings.  Additionally, it is not clear
how the on-disk layout is modified for a distributed setting.

The G* system~\cite{Labouseur2015} manages graphs that correspond to
periodic snapshots, with the focus on efficient data layout.  It takes
advantage of the similarity between successive snapshots by storing
shared vertices only once and maintaining per-graph indexes.  Time is
not an intrinsic part of the system, as there is in \tga, and thus
temporal queries with time predicates like node creation are not
supported.  G* provides two query languages: procedural query language
PGQL, and a declarative graph query language (DGQL). PGQL provides
graph operators such as retrieving vertices and their edges from disk
and non-graph operators like aggregate, union, projection, and join.
All operators use a streaming model, i.e. like in traditional DBMS,
they pipeline.  DGQL is similar to SQL and is converted into PGQL by
the system.  G* on-disk layout supports a custom distributed
environment, although not for a share-nothing cloud architecture with
a distributed file system as snapshot data is stored on specific
machines with no replication.  There is some overlap in query
expressiveness between G* and \tga, as we summarize in
Table~\ref{tab:systems}.  Most notably, \tga attribute node creation
is similar to G*'s AggregationOperator and the support for snapshot
analytics is comparable.  However, there are no counterparts to \tga
aggregate messages, temporal node creation, or edge creation, and no
support for recusion.

Finally, the Historical Graph Store (HGS) system is an evolving graph
query system based on Spark~\cite{Khurana2016}.  It uses the property
graph model and supports retrieval tasks along time and entity
dimensions through Java and Python API.  It provides a range of
operators such as selection (equivalent to our subgraph operators but
with no temporal predicates), timeslice, nodecompute (similar to map
but also with no temporal information), as well as various
evolution-centered operators.  HGS does not provide formal semantics
for any of the operations it supports and the main focus is on
efficient on-disk representation for retrieval.

\tga is strictly more expressive than any of the three systems
described above and is the only evolving graph algebra to provide node
and edge creation as well as suport for temporal predicates.

\eat{Kan et al.~\cite{Kan2009} propose a query model for
discovering subgraphs that match a specific spatio-temporal pattern.
Chan et al.~\cite{Chan2008} query evolving graphs for patterns
represented by waveforms.  Semertzidis et al.~\cite{Semertzidis2015}
focus on historical reachability queries.}

\eat{Efficient physical representations using deltas are investigated
in~\cite{Khurana2013}.  Their on-disk representation is compatible
with the period-based model, but the logical model and the algorithms
for retrieval are snapshot-based.  Their in-memory GraphPool maintains
a single representation of all snapshots, and stores only dependencies
from a materialized snapshot when deltas are small.  Evaluation of
queries involving multiple snapshots, such as aggregation, requires
fully materialized views in memory, which makes this approach
infeasible for our purposes.  }
%Snapshot retrieval is a useful operation
%for many types of analysis and thus should be supported.  In our model
%a snapshot at any time $t$ can be retrieved by temporal slice.

\eat{Ren et al.~\cite{Ren2011} develop an in-memory representation of
  evolving graphs based on representative graphs for sets of
  snapshots.  Their notion of a representative graph differs from
  ours, in that it indicates a union or an intersection between a set
  of consecutive snapshots rather than being a consistent
  representation of the graph for some period $p$.  Nevertheless,
  Ren's representative graphs can be computed in \ql using temporal
  aggregation.}

\eat{Semertzidis et al.~\cite{Semertzidis2015} develop a version graph,
where each node and edge is annotated with the set of time intervals
in which they exist.  Their model is also a sequence of snapshots with
the integer time domain.  The version graph can be extended to support
the period-based model, and is similar to our \og 
representation.}
%
\eat{Boldi et al.~\cite{Boldi2008} present a space-efficient non-delta
  approach for storing a large evolving Web graph that they harvested,
  representing purely topological information, with no vertex or edge
  attributes.\eat{ However, a separate column store could be added for
    those attributes with relative ease.}}

\eat{Another commonly used graph model is the continuous time model based
on change streams~\cite{Cheng2012,Ediger2012}, usually to support
analysis of the latest state of the graph.  Here, stream $S$ emits a
sequence of graph change events $e$, each associated with a time $t$
at which it was emitted.\eat{ An event can be of entity creation,
  deletion, or change in the value of one of the entity attributes.
  Multiple events may be associated with one time instance and the
  event emit rate is not constant.}\eat{ Because the stream emits
  individual entities rather than whole graphs, graph snapshots can
  only be reconstructed by maintaining the history of changes over
  time. } A \tg can be constructed from a change stream following the
conventional temporal database approach of maintaining valid-time
data.}

\eat{
This approach assumes that no events arrive out of order and there are
no redundant or duplicate events.  However, it would be a simple
extension to relax these two assumptions.  We also use a closed world
assumption -- if no event is recorded, for our purposes it did not
occur.
}


%A further difference is that our work is in
%scope of Apache Spark, a widely-used open source platform, while
%ImmortalGraph is a proprietary stand-alone prototype.
