\section{Query Language}
\label{sec:lang}

Our language supports both unary and binary operators. They are:
\begin{itemize}
\item T-Select -- select a temporal subset based on a temporal expression.
\item S-Select -- select a subgraph for every snapshot (selection over V and E).
\item Aggregation -- change the granularity of the graph based on predefined semantics.
\item Transform -- modify the structural schema of the graph (similar to a map operation in map-reduce).
\item Graph analytics -- compute an analytic over all snapshots of the graph.
\item Union -- compute union of two temporal graphs.
\item Intersection -- compute intersection of two temporal graphs.
\end{itemize}

\begin{definition} [T-Select]
\label{def:tsel}
A time selection operator $T-\sigma_\phi(T) = (G_x, \ldots, G_y; P')$ is
a temporal subset operator on $T$ with propositional formula $\phi$
over $P$, where $1 \leq x,y \leq n$, $P' \subset P$.  The
propositional formula is a time expression over $P$.
\end{definition}

Time select operator changes the temporal schema of graph $T$ while
keeping the structural schema intact.

Similar to ~\cite{Khurana2013}, we support the following types of time expressions:

\begin{itemize}

\item Time iterval.  Any valid time interval $[p.start,p.end)$ can be
  used for T-Select.  The selected temporal sequence is the interval
  intersection \ref{def:tseqii} of the input time interval and T's
  temporal sequence P.  I.e., only the overlapping portion of T's
  temporal sequence and input period p will be selected.

\item Interval predicate.  A predicate that can be applied to each
  time interval $p_i \in P$.  Because a temporal sequence does not
  allow for any gaps, empty snapshots are inserted in each time
  interval that does not meet the selection criteria.  \vera{I am not
    sure if I like this...}

\end{itemize}

\vera{Khurana also supports single time point selection, but I don't
  think this goes well with our model.}

For example, T-Select over graph T with temporal sequence
$[1,3),\ldots,[9,11)$ with argument [3,12) results in a $T'$ with $P'
      = [3,11)$.  In contrast, for the same graph T with argument
        [4,6) results in a null sequence $\emptyset$ because there is
          no valid overlap.

\begin{definition}
\label{def:ssel}
A structure select operator $S-\sigma_\phi(T)$ returns a structural
subgraph $T'= (G_1', \ldots, G_n'; P)$ on $T$, where $\forall i \in 1
\ldots n, V'_i \subseteq V_i$, $E'_i \subseteq E_i$. The temporal
schema of the temporal graph is not affected, i.e. $T.P = T'.P$.

\vera{But what happens if the subgraph operation on the last (or
  first) snapshot results in an empty snapshot? Should we tighten the
  interval so that P' is subset of P or keep P as is and have empty
  snapshots? What we have above is option b which I think is more
  consistent.}
\end{definition}

\begin{definition}
\label{def:agg}
An aggregation operator $G f(V_i) g(E_i) (T)$ returns a subgraph 

$T' = (G_1', \ldots, G_m', P')$, where $\forall G_i' = \cup(G_{i},
\cdots, G_{i+r'-1})$ for existential semantics and $\cap(G_{i},
\cdots, G_{i+r'-1})$ for universal semantics.  $f(V_i)$ is a function
applied to node attribute values of nodes with the same identity.
Similarly, $g(E_i)$ is a function applied to edge attribute values
with the same identity. \vera{We need to express somehow that if |GS|
  is not evenly divisible by r', we reduce or increase as needed to
  hold the size/resolution constraint.}
\end{definition}

Aggregation changes temporal schema of the graph, while keeping the
snapshot schema.

For example, consider the temporal graph in Figure~\ref{fig:agg}.

\begin{figure}
\label{fig:agg}
\caption{...}
\end{figure}

\begin{definition}
\label{def:transform}
A transform operator $map f(V_i) g(E_i) (T)$ is a modification
function on T which returns $T' = (G_1', \cdots, G_n', P)$ where
$\forall V_i' = f(V_i), E_i' = g(E_i)$.
\end{definition}

The transform operator keeps the graph temporal schema, as well as
snapshot structure, while modifying snapshot schema and/or values,
computed 1 node at a time.  This is similar to the map operation in
MapReduce.

