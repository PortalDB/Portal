\subsection{Query Optimization}
\label{sec:sys:optimization}

The declarative nature of \ql means that, like in SQL, queries can be
optimized for better performance.  \ql optimizations can be done by
operator reordering, application of best data structure and partition
strategy based on rules, and cost-based optimizations.  We now discuss
the first two options.

{\bf Operator reording.} Recollect that the logical order of
evaluation of a \ql query is selection, join, aggregation, and,
finally, analytics and projection.  We can show that there are classes
of queries which can be reordered without the loss of correctness.

{\bf Aggregation before join.}  Temporal aggregation produces a
smaller number of snapshots than its input.  Since the performance of
joins depends on the number of snapshots being structurally joined,
smaller number of snapshots will lead to faster performance.  Consider
this query:

\begin{small}
\begin{verbatim}
    TSelect Any V; Any E
    From    T1 TOr T2
    TGroup  by 5 years
\end{verbatim}
\end{small}

Assuming that T1 and T2 have 1-year resolution, \insql{TGroup} will
produce 20\% fewer graphs to join.  This reordering cannot be applied
every time, however, because an invalid result can be produced.  For
example, if T1 and T2 are those in Figures~\ref{fig:tg}
and~\ref{fig:tg_t2}, then an aggregation would produce graphs with
temporal schema ([2010, 2015), [2015, 2020)) for T1 and ([2008, 2013),
      [2013, 2018)) for T2, which are not union-compatible.  We check
        that the temporal schema of aggregated graphs is
        union-compatible and apply the reordering only if it is.

{\bf \insql{TAnd} join before temporal selection.}  Temporal
intersection between two graphs with a small temporal overlap can cut
down on graph loading time significantly.  Consider this query:

\begin{small}
\begin{verbatim}
   TSelect All V; All E
   From    T1 TAnd T2
\end{verbatim}
\end{small}

There is an implicit temporal selection here over the entire T1 and T2
duration.  If the T1 and T2 temporal bounds are known, then the query
can be rewritten with an explicit temporal selection matching the
length of the overlap.  In the case of example graphs T1 and T2 from
Section~\ref{sec:example}, we can rewrite the query like this:

\begin{small}
\begin{verbatim}
   TSelct All V; All E
   From   T1 TAnd T2
   TWhere T1.Start >= 2010 And T2.End <= 2014 
          And T2.Start >= 2010 And T2.End <= 2014
\end{verbatim}
\end{small}

This rewriting reduces the loading size of T1 and T2 by 30\% and,
since loading time is linearly dependent on loading size (as we show
in the next section), reduces the overall query time by about the same
amount.

{\bf Projection before aggregation or join.}  Recollect that
aggregation and joins operate not only on the graph structure, but
also graph attributes.  In some cases, the values of some or all of
those attributes are irrelevant to the query, and the attribute
aggregation can be greatly reduced or eliminated.  Consider query Q6
from Section~\ref{sec:example}, reproduced here for convenience:

\begin{small}
\begin{verbatim}
     TSelect   All V[vid, pagerank() as pr]; 
               Any E[vid1, vid2, sum(cnt)]
     From      T1 TOr T2
\end{verbatim}
\end{small}

T1 and T2 vertices have two attributes: name and salary, but they are
irrelevant to this particular query.  We can project T1 and T2 to
\insql{V [vid]} prior to evaluation of the \insql{TOr} operation for
better performance.  However, we cannot apply analytics in projection
before the other operations, so we cannot always perform projection
first.

{\bf Data Structure selection.} In addition to selecting the most
efficient order of operations, we select the best data structure for
the query.  Our analysis of data structures' effectiveness for each
individual operation is shown in the next section.  Switching between
data structures from operation to operation is possible but
computationally inefficient.  In general, however, SnapshotGraph
performs better on graphs with a small temporal span, while OneGraph
on those with large span.

\eat{Instead, we pick the structure that
provides the best compromise for the query operations by associating
costs with each operation and picking the least expensive one.}

{\bf Partitioning.} In our experience, the partitioning of the data
affects the performance more than the data structure choice itself.  A
poor partition strategy, in terms of the correct number of partitions
and the allocation of edges to partitions, can be 10x times slower
than a good one, as we show in the next section.  We evaluated
different strategies and partition numbers experimentally and this
serves as a basis of simple rules for partition selection.  For
example, EdgePartition2D strategy provides a significantly better
performance for snapshot-based structural analytics such as pagerank.

Other criteria that can affect the query performance are data skew,
change rate between snapshots, and data size.  We continue to evaluate
these aspects and will incorporate them into the query optimization.
