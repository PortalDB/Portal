\subsection{Operator Reordering}
\label{sec:sys:optimization}

The logical order of evaluation of a \ql query without nesting is as
follows: (1) temporal selection (\insql{TWhere}); (2) temporal join
(\insql{TAnd} or \insql{TOr}); (3) temporal aggregation
(\insql{TGroup}); (4) projection, computation of attribute value
aggregated and analytics (\insql{TSelect}).  While the logical order
of operations is predetermined, some operators can be reordered
without affecting the result, but with potential differences in
performance, while others cannot. 

\eat{ The declarative nature of \ql means that, like in SQL, queries
  can be optimized for better performance.  \ql queries can be
  optimized by operator reordering, rule-based application of best
  data structure and partition strategy, and cost-based optimizations.
  We discuss the first two options.}

\eat{
{\bf Operator reording.} Recollect that the logical order of
evaluation of a \ql query is selection, join, aggregation, and,
finally, analytics and projection.  We can show that there are classes
of queries which can be reordered without the loss of correctness.}

{\bf \insql{TGroup} before join.}  Temporal aggregation produces a
smaller number of snapshots than its input.  Since the performance of
joins depends on the number of snapshots being structurally joined,
smaller number of snapshots will lead to faster performance.  Consider
this query:

\begin{small}
\begin{verbatim}
    TSelect Any V; Any E
    From    T1 TOr T2
    TGroup  by 5 years
\end{verbatim}
\end{small}

Assuming that T1 and T2 have 1-year resolution, \insql{TGroup} will
reduce the number of graphs to be joined by a factor of 5.  Therefore,
it seems beneficial to apply \insql{TGroup} to each T1 and T2 first,
and to the compute \insql{TOr} of the result.  Unfortunately this
reordering is not always possible.  For T1 and T2 in
Figures~\ref{fig:tg} and~\ref{fig:tg_t2}, aggregation produce \tgs
with temporal schema ([2010, 2015), [2015, 2020)) for T1 and ([2008,
      2013), [2013, 2018)) for T2.  The two \tgs are not temporally
        union-compatible and so cannot be joined.

{\bf \insql{TAnd} before temporal selection.}  Temporal intersection
between two graphs with a small temporal overlap can cut down on graph
loading time significantly.  Consider this query:

\begin{small}
\begin{verbatim}
   TSelect All V; All E
   From    T1 TAnd T2
\end{verbatim}
\end{small}

If temporal bounds of T1 and T2 are known, the query can be rewritten
with an explicit temporal selection matching the length of the
overlap.  For T1 and T2 in Figures~\ref{fig:tg} and~\ref{fig:tg_t2},
the rewriting is:

\begin{small}
\begin{verbatim}
   TSelct All V; All E
   From   T1 TAnd T2
   TWhere T1.Start >= 2010 And T2.End <= 2014 
          And T2.Start >= 2010 And T2.End <= 2014
\end{verbatim}
\end{small}

This rewriting reduces the loading size of T1 and T2 by $\frac{1}{3}$
(ignoring temporal skew).  As we will show in Section~\ref{sec:exp},
loading time is a significant portion of the over-all time, and
reducing it will have a noticeable effect on performances.

{\bf Projection before aggregation or join.}  Recollect that
aggregation and join operate not only on graph structure, but also on
vertex and edge attributes.  In some cases, the values of some or all
of those attributes are irrelevant to the query, and attribute
aggregation can be greatly reduced or eliminated.  Consider query Q6
from Section~\ref{sec:example}, reproduced here for convenience:

\begin{small}
\begin{verbatim}
     TSelect   All V[vid, pagerank() as pr]; 
               Any E[vid1, vid2, sum(cnt)]
     From      T1 TOr T2
\end{verbatim}
\end{small}

Vertices of T1 and T2 have non-key attributes \insql{name} and
\insql{salary}, which are not used in this query. Therefore, to
improve performance, we can project the vertices of T1 and T2 to
\insql{V [vid]} prior to evaluation of the \insql{TOr} operation.
\eat{However, we cannot apply analytics in projection before the other
  operations, so we cannot always perform projection first.}

\eat{
{\bf Data structure selection.} \eat{In addition to selecting the most
  efficient order of operations,}We select the best data structure for
the query.  Our analysis of data structure effectiveness for each
individual operation is shown in Section~\ref{sec:exp}.  Switching
between data structures from operation to operation is possible but
computationally inefficient.  In general, SnapshotGraph performs
better on graphs with a small temporal span, while OneGraph on those
with large span.}

\eat{Instead, we pick the structure that
provides the best compromise for the query operations by associating
costs with each operation and picking the least expensive one.}

\eat{{\bf Partitioning.} In our experience, the partitioning of the data
affects the performance more than the data structure choice itself.  A
poor partition strategy, in terms of the correct number of partitions
and the allocation of edges to partitions, can be 10x times slower
than a good one, as we show in the next section.  We evaluated
different strategies and partition numbers experimentally and this
serves as a basis of simple rules for partition selection.  For
example, EdgePartition2D strategy provides a significantly better
performance for snapshot-based analytics such as pagerank.}

\eat{Other criteria that can affect the query performance are data skew,
change rate between snapshots, and data size.  We continue to evaluate
these aspects and will incorporate them into the query optimization in
the future.}
