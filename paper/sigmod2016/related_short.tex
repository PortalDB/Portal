\section{Related Work}
\label{sec:related}

The research related to our \ql system is in the areas of queries for
evolving graphs, efficient evolving graph representation, on disk or
in memory, and frameworks / graph partitioning.  We discuss each of
these in turn.

{\bf Querying and analytics.} \ql is the first proposed declarative
query language for evolving graphs.  There has been much recent work
on analytics for evolving graphs,
see~\cite{DBLP:journals/csur/AggarwalS14} for a survey. This line of
work is synergistic with ours, since our aim is to provide systematic
support for scalable querying and analysis of evolving graphs.

Several researchers have proposed individual queries, or classes of
queries, for evolving graphs, but without a unifying syntax or general
framework.  Kan et al.~\cite{Kan2009} propose a query model for
discovering subgraphs that match a specific spatio-temporal pattern.
Chan et al.~\cite{Chan2008} query evolving graphs for patterns
represented by waveforms.  Semertzidis et al.~\cite{Semertzidis2015}
focus on historical reachability queries.

Our work shares motivation with Miao et
al.~\cite{DBLP:journals/tos/MiaoHLWYZPCC15}, who developed an
in-memory execution engine for temporal graph analytics called
ImmortalGraph.  Unlike Miao et al., who focus on in-memory layout and
locality-aware scheduling mechanisms, we work in a distributed storage
and processing environment.  A further difference is that our work is
in scope of Apache Spark, a widely-used open source platform, while
the work of Miao et al. is on a proprietary stand-alone prototype.
Nonetheless, several important insights of Miao et al. are relevant,
and we discuss them below.

\eat{
Our work is differs from query processing on dynamic graphs
(e.g.,~\cite{Mondal2012}), where the history of changes is not
important, and the focus is on updating the results as the graph
undergoes changes.  Our work is also different than mining evolving
graph streams (e.g.,~\cite{Liu2010}), where the focus is on discovery
of significant changes over a small window of consecutive graphs.}

Our work differs from query processing on dynamic graphs
(e.g.,~\cite{Mondal2012}), where the history of changes is not
important, and from mining evolving graph streams
(e.g.,~\cite{Liu2010}), where the focus is on discovering significant
changes.

\eat{Our contribution is an implementation-independent declarative language
to support both iterative analytics and building-block operations such
as joins and aggregations.}

{\bf Data representation.}  Another important area of research is
efficient storage, retrieval and in-memory representation of evolving
graphs.  

The basic building block in \ql is a snapshot, which naturally limits
the resolution at which changes can be retrieved. This deliberate
choice is in contrast with delta-based
approaches~\cite{Khurana2013,Koloniari2012,DBLP:journals/tos/MiaoHLWYZPCC15}.`

Khurana and Deshpande~\cite{Khurana2013} investigate efficient
physical representations using deltas to support snapshot retrieval.
Their in-memory GraphPool maintains a single representation of all
snapshots, and is thus similar to our MultiGraph and OneGraph.
GraphPool goes further and stores only dependencies from a
materialized snapshot when deltas are small.  We do not take
this step because evaluation of queries involving multiple snapshots,
such as \insql{TGroup}, requires fully materialized views in memory.
The snapshot group method of~\cite{DBLP:journals/tos/MiaoHLWYZPCC15}
is similar to GraphPool in~\cite{Khurana2013}.

Ren et al.~\cite{Ren2011} develop an in-memory representation of
evolving graphs based on computing and storing representative graphs
for sets of snapshots, and recording deltas from representative graphs
to individual snapshots.  Note that representative snapshots can be
computed using structural aggregation in \ql, and so this work
provides additional motivation for our temporal aggregation and join
operators.  Furthermore, our OneGraph can be thought of as a
representative graph for the whole selected time period.

Semertzidis et al.~\cite{Semertzidis2015} develop a version graph,
where each node and edge are annotated with the set of time intervals
in which they exist.  This is similar to our OneGraph, but we also
store non-topological attributes.  We also do not compress consecutive
existence intervals with the same value into one, because this would
make \insql{TGroup} and snapshot analytics more complex and more
difficult to parallelize.

Boldi et al.~\cite{Boldi2008} present a space-efficient non-delta
approach for storing a large evolving Web graph that they harvested.
Their approach for encoding the presence or absence of nodes and edges
at each time interval using bits is similar to our MultiGraph and its
use of BitSets.  The primary difference is that their work represents
purely topological information and does not address vertex and edge
attributes.

Miao, et al.~\cite{DBLP:journals/tos/MiaoHLWYZPCC15} demonstrate that
there is a trade-off between temporal and spatial locality based on the
type of query.  Their solution is to keep multiple data replicas on
disk and pick the better one for the type of query requested.  In our
work we also explore the trade-offs between structural and temporal
locality.  \eat{However, our focus is on in-memory query evaluation and not
on on-disk layout.}

{\bf Distributed frameworks, partitioning.}  In this paper we build
upon, and non-trivially extend, the graph processing abstractions of
Apache Spark, a popular open-source distributed data processing
engine, and specifically of
GraphX~\cite{DBLP:conf/osdi/GonzalezXDCFS14}.  GraphX provides an API
for working with regular graphs (snapshots), without the time
dimension.  As described in~\ref{sec:sys}, we build our \tgs on top
of GraphX Graph.  To improve performance, we modified the GraphX graph
loading code, enabling concurrent distributed multi-file loading with
a tuned number of partitions.  

Distributed graph computation requires balanced graph partitioning,
dependent on the nature of the operation being applied to the graph.
There are two basic types of graph partitioning strategies: edge-cut
and vertex-cut.  An edge-cut approach distributes vertices across the
available machines and replicates the edges as necessary.  A
vertex-cut approach does the opposite.  Based on extensive theoretical
and experimental studies~\cite{Gonzalez2012}, GraphX chose the
vertex-cut approach.  We use built-in GraphX partitioning and develop
additional vertex-cut strategies that incorporate the temporal
dimension.

Another relevant framework is SparkSQL~\cite{Xin2013}, which provides
mid-query optimization of distributed execution.  Mid-query
optimization is in our immediate plans for \ql.  Another relevant
aspect of SparkSQL is that tables that are often joined are
co-partitioned at creation time.  This is similar to what our data
structures and partition strategies achieve for \insql{TGroup} and
temporal join.


