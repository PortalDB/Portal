\section{Related Work}
\label{sec:related}

{\bf Querying and analytics.}  \ql is the first proposed declarative
query language for evolving graphs.  There has been much recent work
on analytics for evolving graphs,
see~\cite{DBLP:journals/csur/AggarwalS14} for a survey. This line of
work is synergistic with ours, since our aim is to provide systematic
support for scalable querying and analysis of evolving graphs.

Several researchers have proposed individual queries, or classes of
queries, for evolving graphs, but without a unifying syntax or general
framework.  Kan et al.~\cite{Kan2009} propose a query model for
discovering subgraphs that match a specific spatio-temporal pattern.
Chan et al.~\cite{Chan2008} query evolving graphs for patterns
represented by waveforms.  Semertzidis et al.~\cite{Semertzidis2015}
focus on historical reachability queries.

Our work shares motivation with Miao et
al.~\cite{DBLP:journals/tos/MiaoHLWYZPCC15}, who developed an
in-memory execution engine for temporal graph analytics called
ImmortalGraph.  Unlike Miao et al., who focus on in-memory layout and
locality-aware scheduling mechanisms, we work in a distributed
processing environment.  A further difference is that our work is in
scope of Apache Spark, a widely-used open source platform, while
ImmortalGraph is a proprietary stand-alone prototype.

Our work differs from query processing on dynamic graphs
(e.g.,~\cite{Mondal2012}), where the history of changes is not
important, and from mining evolving graph streams
(e.g.,~\cite{Liu2010}), where the focus is on discovering significant
changes.

{\bf Data representation.}  The basic building block in \ql is a
snapshot, which naturally limits the resolution at which changes can
be retrieved. This deliberate choice is in contrast with delta-based
approaches~\cite{Khurana2013,Koloniari2012,DBLP:journals/tos/MiaoHLWYZPCC15}.

Khurana and Deshpande~\cite{Khurana2013} investigate efficient
physical representations using deltas to support snapshot retrieval.
Their in-memory GraphPool maintains a single representation of all
snapshots, and is thus similar to our MultiGraph and OneGraph.
GraphPool goes further and stores only dependencies from a
materialized snapshot when deltas are small.  We do not take
this step because evaluation of queries involving multiple snapshots,
such as \insql{TGroup}, requires fully materialized views in memory.
The snapshot group method of~\cite{DBLP:journals/tos/MiaoHLWYZPCC15}
is similar to DeltaGraph in~\cite{Khurana2013}.

Ren et al.~\cite{Ren2011} develop an in-memory representation of
evolving graphs based on representative graphs for sets of snapshots.
Representative graphs can be computed using structural aggregation in
\ql, and so this work provides additional motivation for our temporal
aggregation and join operators.  Our OneGraph can be thought of as a
representative graph for the whole selected time period.  In the
future we may consider a hybrid approach similar to~\cite{Ren2011},
materializing multiple OneGraphs for different sets of snapshots if a
single representation becomes too dense.

Semertzidis et al.~\cite{Semertzidis2015} develop a version graph,
where each node and edge are annotated with the set of time intervals
in which they exist.  This is similar to our OneGraph, but we also
store non-topological attributes.  We also do not compress consecutive
existence intervals with the same value into one, because this would
make \insql{TGroup} and snapshot analytics more complex and more
difficult to parallelize.

Boldi et al.~\cite{Boldi2008} present a space-efficient non-delta
approach for storing a large evolving Web graph that they harvested.
Their approach for encoding the presence or absence of nodes and edges
at each time interval using bits is similar to our MultiGraph and its
use of BitSets.  The primary difference is that their work represents
purely topological information and does not address vertex and edge
attributes.

{\bf Distributed frameworks.}  We build upon
GraphX~\cite{DBLP:conf/osdi/GonzalezXDCFS14}, which provides an API
for working with regular graphs (snapshots) in Apache Spark, but
without the time dimension.  To improve performance, we modified the
GraphX graph loading code, enabling concurrent distributed multi-file
loading with a tuned number of partitions.  We use built-in GraphX
partitioning and develop additional vertex-cut strategies that
incorporate the temporal dimension.  Another relevant framework is
SparkSQL~\cite{Xin2013Shark}, which provides mid-query optimization of
distributed execution.  Mid-query optimization is in our immediate
plans for \ql.  In SparkSQL tables to be joined can be co-partitioned
at creation time.  This is similar to what our data structures and
partition strategies achieve for \insql{TGroup} and temporal join.


