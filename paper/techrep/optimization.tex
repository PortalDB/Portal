\subsection{Operator Reordering}
\label{sec:sys:optimization}

The logical order of evaluation of a \ql query without nesting is as
follows: (1) temporal selection (\insql{TWhere}); (2) temporal join
(\insql{TAnd} or \insql{TOr}); (3) temporal aggregation
(\insql{TGroup}); (4) projection, computation of attribute value
aggregated and analytics (\insql{TSelect}).  While the logical order
of operations is predetermined, some operators can be reordered
without affecting the result, but with potential differences in
performance, while others cannot. 

{\bf \insql{TGroup} before join.}  Temporal aggregation produces a
smaller number of snapshots than its input.  Since the performance of
joins depends on the number of snapshots being structurally
aggregated, a smaller number of snapshots will lead to better
performance.  Consider this query:

\begin{small}
\begin{verbatim}
    TSelect Any V; Any E
    From    T1 TOr T2
    TGroup  by 5 years
\end{verbatim}
\end{small}

Assuming that T1 and T2 have 1-year resolution, \insql{TGroup} will
reduce the number of graphs to be aggregated by a factor of 5.
Therefore, it seems beneficial to apply \insql{TGroup} to each T1 and
T2 first, and to then compute \insql{TOr} of the result.  Unfortunately
this reordering is not always possible.  For T1 and T2 in
Figures~\ref{fig:tg} and~\ref{fig:tg_t2}, \insql{TGroup} produces \tgs
with temporal schema ([2010, 2015), [2015, 2020)) for T1 and ([2008,
      2013), [2013, 2018)) for T2.  The two \tgs are not temporally
        union-compatible and so cannot be joined.

{\bf \insql{TAnd} before temporal selection.}  Temporal intersection
between two graphs with a small temporal overlap can cut down on graph
loading time significantly.  Consider this query:

\begin{small}
\begin{verbatim}
   TSelect All V; All E
   From    T1 TAnd T2
\end{verbatim}
\end{small}

If temporal bounds of T1 and T2 are known, the query can be rewritten
with an explicit temporal selection matching the length of the
overlap.  For T1 and T2 in Figures~\ref{fig:tg} and~\ref{fig:tg_t2},
the rewriting is:

\begin{small}
\begin{verbatim}
   TSelect All V; All E
   From    T1 TAnd T2
   TWhere  T1.Start >= 2010 And T1.End < 2014 
           And T2.Start >= 2010 And T2.End < 2014
\end{verbatim}
\end{small}

This rewriting reduces the loading size of T1 and T2 by $\frac{1}{3}$
(ignoring temporal skew).  As we will show in Section~\ref{sec:exp},
loading time is a significant portion of the over-all time, and
reducing it will have a noticeable effect on performances.

{\bf Projection before aggregation or join.}  Recollect that temporal
aggregation and join operate not only on graph structure, but also on
vertex and edge attributes.  In some cases, the values of some or all
of those attributes are irrelevant to the query, and attribute
aggregation can be greatly reduced or eliminated.  Consider query Q6
from Section~\ref{sec:example}, reproduced here for convenience:

\begin{small}
\begin{verbatim}
     TSelect   All V[vid, pagerank() as pr]; 
               Any E[vid1, vid2, sum(cnt)]
     From      T1 TOr T2
\end{verbatim}
\end{small}

Vertices of T1 and T2 have non-key attributes \insql{name} and
\insql{salary}, which are not used in this query. Therefore, to
improve performance, we can project the vertices of T1 and T2 to
\insql{V [vid]} prior to evaluation of the \insql{TOr} operation.

